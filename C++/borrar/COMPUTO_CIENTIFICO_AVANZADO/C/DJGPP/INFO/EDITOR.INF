This is Info file editor.inf, produced by Makeinfo version 1.67 from the
input file editor.num.

START-INFO-DIR-ENTRY
* SET's Editor: (editor.info). AN EDITOR FOR PROGRAMMERS.
END-INFO-DIR-ENTRY

This is the documentation for SET's Editor.

Copyright (C) 1996, 1997 Salvador Eduardo Tropea

This documentation may be freely distributed, provided this copyright
notice is left intact on all copies.


File: editor.inf,  Node: Top,  Prev: (dir),  Up: (dir)

EDITOR
******

This is the documentation for SET's Editor.

Copyright (C) 1996, 1997 Salvador Eduardo Tropea

This documentation may be freely distributed, provided this copyright
notice is left intact on all copies.

The following master menu lists the major topics in this documentation,
including all the indices.

* Menu:

* Introduction::
* Available commands::
* Keyboard::
* Editing Modes::
* Calculator::
* How to contact me::
* Index::
* Index of key commands::


File: editor.inf,  Node: Introduction,  Next: Available commands,  Prev: Top,  Up: Top

1 Introduction
**************

   This document describes the use of the SET's editor; this editor was
designed for programmers and to be used alone or inside of the RHIDE.

   This documentation may be freely distributed with the editor or the
RHIDE package or any part thereof, provided this copyright notice is left
intact on all copies.

   Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

  People who helped me develop the editor:

   * ROBERT H”HNE <Robert.Hoehne@Mathematik.TU-Chemnitz.DE>
     (with some base routines, a lot of patches and reports)

   * MOLNAR LASZLO <molnarl@cdata.tvnet.hu>
     (with the calculator, tests and a lot of ideas)

   * MAREK HABERSACK <grendel@ananke.amu.edu.pl>
     (with tests and a lot of ideas)

   * FRANK DONAHOE <fdonahoe@wilkes1.wilkes.edu>
     (with a lot of corrections to this text)

  The editor is freeware, but the source-code of this editor is copyrighted
by Salvador Eduardo Tropea.  If you want to include the editor in your
application, using the whole code or only a part contact at first ME
<salvador@inti.edu.ar>

  This editor is included in the Robert H”hne's RHIDE as a replacement for
the original TVision's editor class.

* Menu:

* What is SETs Editor?::
* Requirements::
* About the Author::


File: editor.inf,  Node: What is SETs Editor?,  Next: Requirements,  Prev: Introduction,  Up: Introduction

1.1 What is SETs Editor?
========================

  SET's editor is an editor designed to be used by programmers; the main
target of the editor is C and C++ code but Pascal and Clipper are supported
too.

  The editor was designed to be very similar to the DOS standard editors for
C, especially to Borland's IDE editor. The editor supports a lot of
WordStar style commands plus some CUA commands, so if you have used any
editor that uses these kinds of commands you'll find my editor very
familiar. On the other hand if you have never used a DOS editor,
especially if you use VI on UNIX machines you'll feel lost. You can
configure the keyboard but this feature is relatively limited. *Note How
to configure the keyboard::.


File: editor.inf,  Node: Requirements,  Next: About the Author,  Prev: What is SETs Editor?,  Up: Introduction

1.2 Requirements
================

  For now I only plan to distribute my editor inside of RHIDE.  Requirements
are the requirements of RHIDE.


File: editor.inf,  Node: About the Author,  Prev: Requirements,  Up: Introduction

1.3 About the Author
====================

0BЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫ
0FЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫ
0BЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫ

The editor was created by Salvador Eduardo Tropea with some code
contributed by Robert H”hne

     E-Mail: SALVADOR EDUARDO TROPEA
     <salvador@inti.edu.ar>
     
     Telephone: (+541) 759-0013
     Postal Address:
     Salvador E. Tropea
     CurapaligЃe 2124
     (1678) Caseros - 3 de Febrero
     Prov: Buenos Aires
     Argentina

0BЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫ
0FЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫ
0BЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫ


File: editor.inf,  Node: Available commands,  Next: Keyboard,  Prev: Introduction,  Up: Top

2 Available commands
********************

  In this section I will explain the features of the editor and the default
configuration for the keyboard. If you want to change some assignment of a
key consult "configure the keyboard".  *Note How to configure the
keyboard::.

  Read the conventions topic first to understand my way of indicating
keystrokes.

  In the description of each command I'll include the internal name used by
the editor because this name is needed to configure the keyboard.

* Menu:

* Conventions::
* Cursor movement::
* Insert and Delete::
* Blocks::
* Pseudo Macros::
* Miscellaneous::


File: editor.inf,  Node: Conventions,  Next: Cursor movement,  Prev: Available commands,  Up: Available commands

2.1 Conventions
===============

  I'll use some conventions when talking about the keystrokes needed to
trigger some command. So here is what I use:

  The key named <Ctrl> or Control is represented as `^'; this key doesn't
have any effect used alone inside of the editor so the `^' symbol will be
used only in conjunction with the name of some key indicating that you
must press the two keys at the same time. For example, `^A' is <Ctrl> and
<A> at the same time.  When I say "at the same time" that means: press
`<Ctrl>', hold it, and press the other key; that's the reason to put <A>
after <Ctrl>.

  To indicate a sequence of keystrokes I'll use a dash to separate the keys.
For example, `^K-B' is <Ctrl> and <K> at the same time, and then press
<B>, of course release `^K' first.

  To indicate keys pressed at the same time other than `^x' I'll use a plus.
For example, `Shift+^Insert' is the three keys at the same time!

  I don't think that you are stupid; the editor is written for programmers,
but I wanted to make that clear to avoid problems ;-).


File: editor.inf,  Node: Cursor movement,  Next: Insert and Delete,  Prev: Conventions,  Up: Available commands

2.2 Cursor movement
===================

   * Character left
     - Command: cmbCharLeft
        - Key: Left arrow
        - Alternate: ^S

   * Character right
     - Command: cmbCharRight
        - Key: Right arrow
        - Alternate: ^D

   * Word left
     - Command: cmbWordLeft
        - Key: ^Left arrow
        - Alternate: ^A

   * Word right
     - Command: cmbWordRight
        - Key: ^Right arrow
        - Alternate: ^F

   * Line up
     - Command: cmbLineUp
        - Key: Up arrow
        - Alternate: ^E

   * Line down
     - Command: cmbLineDown
        - Key: Down arrow
        - Alternate: ^X

   * Scroll the screen one line up
     - Command: cmbScrollUp
        - Key: ^W
        - Alternate:

   * Scroll the screen one line down
     - Command: cmbScrollDown
        - Key: ^Z
        - Alternate:

   * Page up
     - Command: cmbPageUp
        - Key: PgUp
        - Alternate: ^R

   * Page down
     - Command: cmbPageDown
        - Key: PgDn
        - Alternate: ^C

   * Beginning of line
     - Command: cmbLineStart
        - Key: Home
        - Alternate: ^Q-S

   * End of line
     - Command: cmbLineEnd
        - Key: End
        - Alternate: ^Q-D

   * Top of window
     - Command: cmbFirstLineInScreen
        - Key: ^Q-E
        - Alternate: ^Home

   * Bottom of window
     - Command: cmbLastLineInScreen
        - Key: ^Q-X
        - Alternate: ^End

   * Top of file
     - Command: cmbTextStart
        - Key: ^Q-R
        - Alternate: ^PgUp

   * Bottom of file
     - Command: cmbTextEnd
        - Key: ^Q-C
        - Alternate: ^PgDn


File: editor.inf,  Node: Insert and Delete,  Next: Blocks,  Prev: Cursor movement,  Up: Available commands

2.3 Insert and Delete
=====================

   * Delete the character under cursor
     - Command: cmbDelChar
        - Key: Del
        - Alternate: ^G

   * Delete character to left
     - Command: cmbBackSpace
        - Key: Backspace
        - Alternate: ^H

   * Delete line
     - Command: cmbDelLine
        - Key: ^Y
        - Alternate:

   * Delete to end of line
     - Command: cmbDelEnd
        - Key: ^Q-Y
        - Alternate: Shift+^Y

   * Delete to start of line
     - Command: cmbDelStart
        - Key: ^Q-H
        - Alternate:

   * Delete word at left
     - Command: cmbDelWord
        - Key: ^T
        - Alternate:

   * Delete word at right
     - Command: cmbDelPrevWord
        - Key: ^Backspace
        - Alternate:

   * Insert line
     - Command: cmbNewLine
        - Key: Enter
        - Alternate: ^N

   * Insert mode on/off
     - Command: cmbInsMode
        - Key: Ins
        - Alternate: ^V

  When you are in insert mode all the typed characters are inserted in the
text, but when the insert mode is off the typed characters replace the old
text. The editor starts with insert mode on. You can quickly know the mode
by the cursor shape. When the insert mode is on, the cursor is only a
line, but when it is off, the cursor is block shaped.


File: editor.inf,  Node: Blocks,  Next: Pseudo Macros,  Prev: Insert and Delete,  Up: Available commands

2.4 Blocks
==========

  A block is a selected portion of the text. You can copy, delete, etc.
blocks of text. The associated commands are:

   * Move to beginning of block
     - Command: cmbGoBeginBlock
        - Key: ^Q-B
        - Alternate:

   * Move to end of block
     - Command: cmbGoEndBlock
        - Key: ^Q-K
        - Alternate:

   * Set beginning of block
     - Command: cmbStartSelect
        - Key: ^K-B
        - Alternate:

   * Set end of block
     - Command: cmbEndSelect
        - Key: ^K-K
        - Alternate:

   * Hide/Show block
     - Command: cmbHideSelect
        - Key: ^K-H
        - Alternate:

   * Mark line
     - Command: cmbMarkLine
        - Key: ^K-L
        - Alternate:

   * Mark word
     - Command: cmbMarkWord
        - Key: ^K-T
        - Alternate:

   * Delete block and copy it to the Clipboard
     - Command: cmbCut
        - Key: ^K-Y
        - Alternate: Shift+Del

   * Copy the selected block
     - Command: cmbCopyBlock
        - Key: ^K-C
        - Alternate:

   * Move block
     - Command: cmbMoveBlock
        - Key: ^K+V
        - Alternate:

   * Copy to Clipboard
     - Command: cmbCopy
        - Key: ^Ins
        - Alternate:

   * Delete block
     - Command: cmbClear
        - Key: ^Del
        - Alternate:

   * Paste from Clipboard
     - Command: cmbPaste
        - Key: Shift+Ins
        - Alternate:

   * Read block from disk
     - Command: cmbReadBlock
        - Key: ^K-R
        - Alternate: Shift+^R

   * Write block to disk
     - Command: cmbWriteBlock
        - Key: ^K-W
        - Alternate: Shift+^W

   * Replace the block by the Clipboard block
     - Command: cmbReplaceSelect
        - Key: Shift+^Ins
        - Alternate:

   * Convert to Uppercase
     - Command: cmbToUpper
        - Key: ^K-M
        - Alternate:

   * Convert to Lowercase
     - Command: cmbToLower
        - Key: ^K-O
        - Alternate:

   * Report the length of the block
     - Command: cmbSelLength
        - Key: ^Q-L
        - Alternate:

* Menu:

* Block modes::
* Selecting with the mouse or Shift::
* Indentation::
* Rectangular Blocks::


File: editor.inf,  Node: Block modes,  Next: Selecting with the mouse or Shift,  Prev: Blocks,  Up: Blocks

2.4.1 Block modes
-----------------

  There are two block modes. One is the mode that the old editor of RHIDE
used. This mode is used in CUA programs. The other is called Persistent
Blocks.

  In the normal mode each time you select a block and then insert anything
in it (with `cmbPaste' or by typing anything) the selected block is deleted
and is replaced by the new text.

  In persistent blocks the selection is not replaced and is not lost when
you move the cursor. From this comes the name "Persistent." In this mode
you can use `cmbMoveBlock' and `cmbCopyBlock' without using the Clipboard.
In addition you can apply indentations to the block (*Note Indentation::),
search only inside it, etc. That's what makes this mode much more powerful
than the former. If you really like to replace the selected text by the
selection of the Clipboard, that's the default behaviour of the first
mode. You can use the `cmbReplaceSelect' command to achieve the same in
the Persistent Blocks mode.


File: editor.inf,  Node: Selecting with the mouse or Shift,  Next: Indentation,  Prev: Block modes,  Up: Blocks

2.4.2 Selecting with the mouse or Shift
---------------------------------------

  The described commands for selecting a block, `cmbStartSelect' and
`cmbEndSelect', are good but not so quick. There are other ways to do this.

* Menu:

* Using the mouse::
* Using the Shift key::


File: editor.inf,  Node: Using the mouse,  Next: Using the Shift key,  Prev: Selecting with the mouse or Shift,  Up: Selecting with the mouse or Shift

2.4.2.1 Using the mouse
.......................

  Using the mouse you need only point to the start place, hold the left
button pressed and move the mouse to the end point of your block.

  To select a word with the mouse just double click on it.


File: editor.inf,  Node: Using the Shift key,  Prev: Using the mouse,  Up: Selecting with the mouse or Shift

2.4.2.2 Using the Shift key
...........................

  Using the <Shift> key you only need to move the cursor to the start point,
hold `<Shift>' pressed and move the cursor to the end point with any of the
available cursor commands. *Note Cursor movement::.


File: editor.inf,  Node: Indentation,  Next: Rectangular Blocks,  Prev: Selecting with the mouse or Shift,  Up: Blocks

2.4.3 Indentation
-----------------

  You can indent or unindent a block of text using various commands, but you
must keep in mind that for now the editor is limited in the following:
*Note Real Tabs:: If you are using tabs to indent your text, don't mix the
tabs with spaces and, if you are using spaces to indent, don't mix them
with real tabs.

   * Indent block one position adding a space
     - Command: cmbIndentBlkOne
        - Key: ^K-I
        - Alternate: Shift+^I

   * Unindent block one character - not an x position
     - Command: cmbUnIndentBlkOne
        - Key: ^K-U
        - Alternate: Shift+^U

   * Indent block
     - Command: cmbIndentBlk
        - Key: ^K-Tab
        - Alternate:

   * Unindent block
     - Command: cmbUnIndentBlk
        - Key: ^K-Shift+Tab
        - Alternate:

   * Smart Indent block
     - Command: cmbSmartIndent
        - Key: ^Tab
        - Alternate:

   * Smart Unindent block
     - Command: cmbSmartUnIndent
        - Key: Shift+^Tab
        - Alternate:

`cmbUnIndentBlkOne' unindents deleting one char at the start of the line so
if the line is indented with tabs the line will retract one tab.

`cmbIndentBlk' acts according to the mode. If you are using tabs, the
editor will put one tab beginning each line. If you aren't using tabs the
editor will operate the Tab command on the first line and then will use
this amount of indentation on the entire block. *Note Real Tabs::.

`cmbUnIndentBlk' acts according to the mode too. *Note Real Tabs:: mode.
This is just like `cmbUnIndentBlkOne' deleting one tab but if you don't
use tabs the editor uses Backspace on the first used column of the first
line of the block and unindents by the resulting amount all the block.

`cmbSmartIndent' and `cmbSmartUnIndent' indents taking as reference the {
} pair where the block is, for example:
       {
     line1
          line2
        line3
       }

After indenting a block that contains line1 to line3 is:
       {
        line1
        line2
        line3
       }

The indentation is made with spaces.


File: editor.inf,  Node: Rectangular Blocks,  Prev: Indentation,  Up: Blocks

2.4.4 Rectangular Blocks
------------------------

  The editor includes a mode where you can select a rectangular portion of
the text and copy, cut, clear, paste, move, etc. this region.  This tool
is very useful for modifications on columns.

  Attention! The selected area is based on the X,Y coordinates. For this
reason if you insert lines before the bottom of the rectangle the area
won't be moved. I don't plan to move the area by now because that takes
some CPU and I think that this selection is made just before using it. So
don't report that like a bug. That is the way it works!

   * Set beginning of block
     - Command: cmbSelRectStart
        - Key: ^K-Shift+B

   * Set end of block
     - Command: cmbSelRectEnd
        - Key: ^K-Shift+K

   * Hide/Show block
     - Command: cmbSelRectHide
        - Key: ^K-Shift+H

   * Delete block and copy it to an special Clipboard
     - Command: cmbSelRectCut
        - Key: ^K-ShiftT

   * Move block
     - Command: cmbSelRectMove
        - Key: ^K+Shift+V

   * Copy to special Clipboard
     - Command: cmbSelRectCopy
        - Key: ^K-Shift+C

   * Delete block
     - Command: cmbSelRectDel
        - Key: ^K-Shift+L

   * Paste from special Clipboard
     - Command: cmbSelRectPaste
        - Key: ^K-Shift+P


File: editor.inf,  Node: Pseudo Macros,  Next: Miscellaneous,  Prev: Blocks,  Up: Available commands

2.5 Pseudo Macros
=================

  This feature is very useful to save some keystrokes. With this feature you
can create a lot of shortcuts to make your life easiest.

* Menu:

* Please enlighten me - what is that?::
* How can I customize that?::


File: editor.inf,  Node: Please enlighten me - what is that?,  Next: How can I customize that?,  Prev: Pseudo Macros,  Up: Pseudo Macros

2.5.1 Please enlighten me - what is that?
-----------------------------------------

  So now, What's a Pseudo Macro? It's like a macro but is triggered by two
things: one the text behind the cursor, and two the `^Space' combination.

  And what's the result? The result is customizable, but by default there are
some predefined behaviours. For example, type in a new window the following
two characters: `#i' and the press `^Space' ...

  Surprised? I bet! You got: #include <.h> and the cursor just in the right
place to write the name of the header.

Now write the famous stdio word, press `<End>', then `<Enter>' twice and
now write the following two letters: `ma' and then `^Space' ...

  I bet this time you predicted better what will happen so you aren't so
surprised ;-). Anyways, Surprise! Now type `pr' and the magic keys and ...
`printf("");' appears. To end the happy history now type "Hello world!"
That's all. You wrote the hello world program at a very good speed.

  Now you know what I mean when I say pseudo-macros.


File: editor.inf,  Node: How can I customize that?,  Prev: Please enlighten me - what is that?,  Up: Pseudo Macros

2.5.2 How can I customize that?
-------------------------------

  Is very easy. There is a file called `pmacros.txt' in the same directory
where you started the editor. This file contains the definitions for each
pseudo macro. You can define up to 32 pseudo macros. (Please tell me if
that isn't enough. I can sacrifice some time to make it dynamically
expandable).

  Important: If you are using RHIDE consult the RHIDE documentation to know
where is stored the `pmacros.txt' file.

  The `pmacros.txt' file is a very good example and is self-explained but
I'll include here one example.

Trigger: "i("
Mode: 0,1,0,1,0
 "if (@0)\n"
 "  {@1\n"
   "}\n"
 "\belse\n"
 "  {@2\n"
   "}"

  The Trigger keyword defines the two letter behind the cursor that will
trigger the pseudo macro.

  The Mode keyword indicates the mode that the editor will use when inserting
the text. The modes are:

   * Overwrite               *Note Overwrite::

   * Autoindent              *Note Autoindent::

   * Use Tabs                *Note Real Tabs::

   * Persistent blocks       *Note Block modes::

   * Intelligent C indent    *Note Intelligent C indent::

  Each mode can be 0 or 1. The editor will return to the original mode after
expanding the pseudo macro. In this case the macro is expanded in the No
overwrite, autoindent, don't use tabs, the blocks are persistent and don't
be smart when indenting.

  The rest is the code to insert surrounded by ". You can use \b to indicate
backspace, \n for newline and \\ to indicate a simple \. If you want to
insert a @ you have to type it twice @@, because this character has a
special meaning (see below).

  After the insertion the cursor is positioned in the place marked with @0.
Don't forget to signal this point or the cursor will positioned at the
beginning of the file. The places marked with @1, @2 and @3 are saved in
the markers 7, 8 and 9.


File: editor.inf,  Node: Miscellaneous,  Prev: Pseudo Macros,  Up: Available commands

2.6 Miscellaneous
=================

   * Autoindent mode on/off
     - Command: cmbIndentMode
        - Key: ^O

   * Find place marker
     - Command: cmbGotoMarkn
        - Key: ^Q n*

   * Set marker
     - Command: cmbPutMarkn
        - Key: ^K n*

   * Search the open curly bracket where the cursor is
     - Command: cmbSearchStart
        - Key: ^[

   * Search the close curly bracket where the cursor is
     - Command: cmbSearchEnd
        - Key: ^]

   * Search the ( where the cursor is
     - Command: cmbSearchOpPar
        - Key: Shift+^9

   * Search the ) where the cursor is
     - Command: cmbSearchClPar
        - Key: Shift+^0

   * Search the [ where the cursor is
     - Command: cmbSearchOpCor
        - Key: Shift+^[

   * Search the ] where the cursor is
     - Command: cmbSearchClCor
        - Key: Shift+^]

   * Undo
     - Command: cmbUndo
        - Key: Alt+Backspace

   * PMacro's Trigger
     - Command: cmbExpandCode
        - Key: ^Space

   * Goto Line
     - Command: cmbGotoEditorLine
        - Key: ^J

   * Set the options of the current window (Not in RHIDE)
     - Command: cmbSetLocalOptions
        - Key: Alt+L

   * Set the default options (Not in RHIDE)
     - Command: cmbSetGlobalOptions
        - Key: Alt+G

   * Convert all tabs in spaces
     - Command: cmbExpandAllTabs
        - Key: From menu

   * Compact the text using tabs
     - Command: cmbCompactBuffer
        - Key: From menu

   * Start recording a macro
     - Command: cmbRecordMacro
        - Key: Shift+F10

   * Stop recording a macro
     - Command: cmbStopMacro
        - Key: Alt+F10

   * Play a macro
     - Command: cmbPlayMacro
        - Key: ^F10


File: editor.inf,  Node: Keyboard,  Next: Editing Modes,  Prev: Available commands,  Up: Top

3 Keyboard
**********

  The editor uses the scancodes of the keys to trigger the different
commands.  You can reconfigure which key triggers some command. In
addition some non-US keyboards can mess the commands so you could need to
configure the editor for your keyboard.

* Menu:

* How to configure the keyboard::
* A program to find the scancodes::


File: editor.inf,  Node: How to configure the keyboard,  Next: A program to find the scancodes,  Prev: Keyboard,  Up: Keyboard

3.1 How to configure the keyboard
=================================

  There are three associated files with the keyboard: `keybind.cc',
`keybind.h' and `keybind.txt'.

  The `keybind.h' file contains the scancode number for each key and the
number for each command. This file is included in `keybind.cc'. If your
keyboard has a different assignment you can modify the scancodes in this
file. For example, the German keyboards have the following sequence QWERTZ
instead of the more common QWERTY, so each time you press `^Z' you won't
get the function of `^Z', but of `^Y' instead. Some can live with it, but
it is fixable.  To fix this problem you must correct the scancode of the Z
key in `keybind.h.' But of course this affects `^Y' too. That's only an
example. The most common problem is with the symbols like {, }, [, etc.
If you don't know how to find the scancode of a key take this link.  *Note
A program to find the scancodes::.

  The `keybind.cc' file is a C++ file but you don't need to compile it and
link with the editor, you only need to preprocess it (I used this method to
save the time needed to make a parser ;-).

  To convert this file into a `keybind.txt' file use:

     cpp keybind.cc > keybind.txt

Where cpp is the C++ preprocessor. Any of the comment systems available in
C++ may be used, as cpp does not pass comments to the file, `keybind.txt'.
I guess that you have cpp, but if not you can use another C++ preprocessor
or even Clipper using the /P switch.

  There are seven sections in the file, each section is the keyboard
translation under certain situation.
The sections are:

   * `NORMAL'
        - Contains: The single key press.

   * `SHIFT'
        - Contains: Shift plus a key.

   * `CONTROL'
        - Contains: Control plus a key.

   * `SHIFT_CONTROL'
        - Contains: Shift plus control plus a key (all at the same time).

   * `QUICK'
        - Contains: A key after `^Q' or whatever you defined as `cmbCtrlQ'.

   * `BLOCK'
        - Contains: A key after `^K' or whatever you defined as `cmbCtrlK'.

   * `BLOCK_SHIFT'
        - Contains: A key plus shift after `^K' or whatever you defined as
     `cmbCtrlK'.

   In each section you must put the keyboards and the command associated to
it.
   Use the following syntax:
     Scan_Code = Command

Not all the scan codes are available. For example, you can't put:
     RSHIFT = xxxxx

   Look at `keybind.h' to see the scan codes labels and the available
commands.

Important Notes:
I)
  The new assignments are mixed with the original assignments, so if you
want to eliminate an old key combination you *must* assign a `cmbNoCommand'
to this key. For example, if you wish eliminate the BACKSPACE key and use
the `^O' instead, you must:
  1. put `BACKSPACE = cmbNoCommand' in the NORMAL section,

  2. put `O = cmbBackSpace' in the CONTROL section.

If you only do part two, you'll not eliminate the BACKSPACE key.

II)
  If some thing is wrong in the `keybind.txt' file the program will inform
the error. The line number is for the `keybind.txt' and not for
`keybind.cc' (Sorry, some day I'll fix this).
To continue the execution press any key and then enter.

III)
  You can repeat an assignment, the last wins:

     BACKSPACE = cmbNoCommand
     BACKSPACE = cmbBackSpace

  The first is ignored.


File: editor.inf,  Node: A program to find the scancodes,  Prev: How to configure the keyboard,  Up: Keyboard

3.2 A program to find the scancodes
===================================

  The author of the following program is Robert H”hne:

#include <stdio.h>
#include <dos.h>

#ifdef __GNUC__
#include <dpmi.h>
#define REGS __dpmi_regs
#define INTR(nr,r) __dpmi_int(nr,&r)
#else
#define REGS union REGS
#define INTR(nr,r) int86(nr,&r,&r)
#endif

unsigned short getshiftstate(void)
{
  REGS r;
  r.h.ah = 0x12;
  INTR(0x16,r);
  return r.x.ax;
}

unsigned short gkey(void)
{
  REGS r;
  r.h.ah = 0x10;
  INTR(0x16,r);
  if (r.h.al == 0xE0 || r.h.al == 0) r.h.al = 0;
  return r.x.ax;
}

main()
{
  unsigned short key;
  do
  {
    key = gkey();
    fprintf(stdout,"%04X, scan code: %d\n",key,key>>8);
  } while (1);
}


File: editor.inf,  Node: Editing Modes,  Next: Calculator,  Prev: Keyboard,  Up: Top

4 Editing Modes
***************

  The editor has nine settings that control the function and aspect of the
editor. Not all can be controlled by RHIDE Beta 6 release 22/10, and I
don't know if all the settings will be supported in the 1.0 release so if
you don't find some setting in RHIDE and you feel that setting is really
needed contact me.

  The settings are:

* Menu:

* Overwrite::
* Autoindent::
* Real Tabs::
* Persistent Blocks::
* Intelligent C indent::
* Column cursor::
* Row cursor::
* Match pair highlight::
* Syntax Highlight::


File: editor.inf,  Node: Overwrite,  Next: Autoindent,  Prev: Editing Modes,  Up: Editing Modes

4.1 Overwrite
=============

  This setting controls if the typed characters are inserted in the buffer or
if the typed characters replace the original ones. *Note Insert and
Delete:: for a detailed explanation.


File: editor.inf,  Node: Autoindent,  Next: Real Tabs,  Prev: Overwrite,  Up: Editing Modes

4.2 Autoindent
==============

  This setting controls what happend when you press <ENTER>. If this setting
is off the cursor goes to the column 1 of a new line. If the mode is on
the editor will try to keep the indentation of the code inserting spaces.


File: editor.inf,  Node: Real Tabs,  Next: Persistent Blocks,  Prev: Autoindent,  Up: Editing Modes

4.3 Real Tabs
=============

  This setting controls what happend when you press `<TAB>'. If this setting
is on the editor will insert an ASCII 9 in this place.

  An ASCII 9 is a TAB, that means that the width of this char is enough to
move the cursor to the next tabulator column. In the editor the tabulator
columns are equidistant and the positions are controled by the Tab Size
value.

  If this setting is off the editor won't put any ASCII 9 in your text.
Instead the editor will insert enough spaces to move the cursor to the
next tab-stop, but if the cursor is positioned on the first character of
the line the editor will insert spaces to move this position to the next
hole in the line over the line where you are. Confused? Sorry for my
English, an example will clarify that:

This is a line over the line where you are

That's the line where the cursor is, at column one.

  After pressing TAB you'll get:

This is a line over the line where you are

     That's the line where the cursor is, at column one.

  Now can ask, Why this? Is that useful? The answer is that's very useful to
keep your code indented, experiment using that under a line with if, for,
etc.

  Another thing controlled by this setting is the behaviour of the
<Backspace> key, when the setting is on the key is just 'delete the
character at the left of the cursor' but when the setting is off this key
is the 'Unindent' key.

  The editor is much more coherent when you choose to use TABs or not use
TABs. If you mix the two modes you'll get some unexpected things, specially
in the indentation of the blocks.

  Is better if you always work in a file without tabs and with this setting
off. Then you'll get much from the editor.

  Now you can say: `But I really need tabs because I'm editing a make file!'
or `because I'll send the file using an ultra slow link and I want the
compression granted by the tabs.' In these cases you can first expand all
tabs, then work without real tabs and at the finish of your work compact
all possible spaces and generate a file with all the tabs that you need.
*Note Miscellaneous:: section.


File: editor.inf,  Node: Persistent Blocks,  Next: Intelligent C indent,  Prev: Real Tabs,  Up: Editing Modes

4.4 Persistent Blocks
=====================

  This setting controls the behaviour of the selected area.

  *Note Block modes:: chapter for a detailed explanation.


File: editor.inf,  Node: Intelligent C indent,  Next: Column cursor,  Prev: Persistent Blocks,  Up: Editing Modes

4.5 Intelligent C indent
========================

  This mode was designed to be used in jointly with the Pseudo Macros (*Note
Pseudo Macros::) and the Real Tabs mode in off to achieve an easy way to
indent the code making a better work than the Autoindent mode.

  In this mode the spaces inserted after pressing <ENTER> depend on the
first word in the last line. For example, if you have:

     if (a==b)_

  With the cursor in the '_' position and press <ENTER> you'll get:

     if (a==b)
       _

  Now you can do either of two things, 1) press space and write the code
that will be executed by the if, or 2) if this a multiline code press {
and <ENTER>.  In the last case you'll get:

     if (a==b)
       {
        _

  Now type your first line of code. Press <ENTER>. Write your next line.
Press <ENTER> again and then <Backspace>:

     if (a==b)
       {
        1st line;
        2nd line;
       _

  Now type } and press <ENTER> one more time:

     if (a==b)
       {
        1st line;
        2nd line;
       }
     _

  As you can see the code is perfectly aligned without a significant work on
your part.

  I tried to make this mode as smart as possible, but needs more work. If
you have suggestions contact me.

  Another important thing is that this indentation has a personal style, my
style ;-), so maybe you don't like it. If that's your case you can do the
following things:

   * Use another way of indentation offered by the editor. For example,
     turn on the Real Tabs mode and indent with tabs.

   * Customize the `pmacros.txt' file (*Note Pseudo Macros::), actually
     this file is coherent with this mode.

   * The editor isn't configurable like Emacs or Brief using a language,
     but is written in C++ and chances that you know C++ are over the 90%
     so contact me and I'll help you to write the routines that you need
     to get an indentation in your own style :-).

* Menu:

* Can you explain to me more about the behavior of this mode?::
* Do you have more examples?::


File: editor.inf,  Node: Can you explain to me more about the behavior of this mode?,  Next: Do you have more examples?,  Prev: Intelligent C indent,  Up: Intelligent C indent

4.5.1 Can you explain to me more about the behavior of this mode?
-----------------------------------------------------------------

  I'll try to describe the behaviour of the mode:

  Each time you press <ENTER> the editor inserts a `\r\n' string in your
text, after that the editor searchs one line located above the new line
that has at least one character inside. This line is taken as reference.
The editor analyzes this line searching for:

   * The first non-blank character on this line.

   * The first word on this line.

   * The first parenthesis.

   * The balance of parentheses on the line.

   * The last non-blank and non-comment character in the line.

  Now, if the line contains { at the start the editor goes to the first
column after the {.

  If the line contains } at the start the editor will go to the same column
of the } and then will perform a <Backspace>. If the Real Tabs mode is
off, that's an unindent. *Note Real Tabs::.

  If the line starts with a C++ comment the effect is the same as in
Autoindent. *Note Autoindent::.

  If the line starts with a C comment the editor will try to skip the
comment and analyze the rest of the line, but if the comment doesn't end
on this line the editor will go to the column where the `/' is.

  If the line starts with `/' the editor goes to this column.

  If the line has more `(' than `)' the editor will go to the column of the
first non-blank after the first `('.

  If the line has more `)' than `(' the editor will search the line where the
number of parentheses is balanced, then will analyze this line. If the
whole line still generates an unbalanced situation the editor will go to
the first used column in the line that was found the first time. But if
this line lets all balanced the editor will take the first word on the
line and will use it as reference.

  At last, and according to the word found, the editor will use this word as
reference. The editor recognises the following keywords:

   * `do'
     - Action: +2 but not if ... ;

   * `if'
     - Action: +2 but not if ... ;

   * `for'
     - Action: +3 but not if ... ;

   * `else'
     - Action: +2

   * `case'
     - Action: +5

   * `while'
     - Action: +2 but not if ... ;

   * `switch'
     - Action: +2

   * `break'
     - Action: unindent

   * `return'
     - Action: unindent

   * `default'
     - Action: +5

  The numbers are how many spaces are added with reference to the first
letter of the word.  'not if ... ;' specified means that, if the line ends
with a semicolon, the editor will do the same as for Autoindent. *Note
Autoindent::. The unindent is performed with <Backspace>.

  Seasick? *Note Do you have more examples?::.

  Note: Some of these features were added in v0.2.14 of the editor based on a
suggestion of <Bradford L. Spencer, stud73@nortel.ca> about the behaviour
of the mode on a line like this `printf("Num: %d",' with the rest of the
parameters on the next line.


File: editor.inf,  Node: Do you have more examples?,  Prev: Can you explain to me more about the behavior of this mode?,  Up: Intelligent C indent

4.5.2 Do you have more examples?
--------------------------------

  Well here are some examples. I used a strange convention, like this: if I
say type `a[ENTER]{', type the letter `a', then press `<ENTER>' and
finally press the `{' key.

Example 1: (Is similar to one explained before but is to show the
convention)

     Type:
     if (a==1)[ENTER]{[ENTER]a=2;[ENTER]b=3;[ENTER][BACKSPACE]}[ENTER]
     
     You'll get:
     
     if (a==1)
       {
        a=2;
        b=3;
       }
     [<--- cursor here]

Example 2: A switch/case example

     Type:
     switch(a)[ENTER]{[ENTER]case 1:[ENTER]a=2;[ENTER]b=3;[ENTER]break;
     [ENTER]case 2:[ENTER]b=5;[ENTER]break;[ENTER][BACKSPACE]}[ENTER]
     
     You'll get:
     
     switch(a)
       {
        case 1:
             a=2;
             b=3;
             break;
        case 2:
             b=5;
             break;
       }
     [<--- cursor here]

Example 3: A call to a function that takes a lot of parameters

     Type:
     printf([SPACE]"Num: %d",[ENTER]a[SPACE]);[ENTER]
     
     You'll get:
     
     printf( "Num: %d",
             a );
     [<--- cursor here]

Example 4: A lot of parentheses

     Type:
     if[SPACE]([SPACE](a==1)[SPACE]||[ENTER](b==2)[SPACE]||[ENTER]
     c[SPACE])[ENTER]
     
     You'll get:
     
     if ( (a==1) ||
          (b==2) ||
          c )
       [<--- cursor here]

Example 5: Comment trying to interfere part 1

     Type:
     /*-a-*/for[SPACE](x=1;x;--x)[ENTER]
     
     You'll get:
     
     /*-a-*/for (x=1;x;--x)
               [<--- cursor here]

Example 6: Comment trying to interfere part 2

     Type:
     for[SPACE](x=1;x;--x);[SPACE]//-b[ENTER]
     
     You'll get:
     
     for (x=1;x;--x); //-b
     [<--- cursor here]

 Note: Of course you can fool the editor but as you can see it is relatively
smart ;-).


File: editor.inf,  Node: Column cursor,  Next: Row cursor,  Prev: Intelligent C indent,  Up: Editing Modes

4.6 Column cursor
=================

  This setting enables an strange feature of the editor, when this mode is
on the column where the cursor is is highlighted. This feature is very good
to check if some part of your code is aligned.

  If you like this mode but is very uncomfortable to use all the time
contact me and if I get enough feedback I'll put this thing in a key to be
turned on/off quickly.


File: editor.inf,  Node: Row cursor,  Next: Match pair highlight,  Prev: Column cursor,  Up: Editing Modes

4.7 Row cursor
==============

  This setting is similar to the column cursor but acts on the row where the
cursor is. If you enable the two modes you'll get a cross on the screen
showing where the cursor is.


File: editor.inf,  Node: Match pair highlight,  Next: Syntax Highlight,  Prev: Row cursor,  Up: Editing Modes

4.8 Match pair highlight
========================

  This mode acts showing the pairs of (/), [/] and {/} on the fly. Each time
you type one of these symbols the editor will search the matching pair, if
the editor finds it and the match is on the screen both will be
highlighted, if the match is outside the screen the editor will inform the
position on the status line, and if there is no match the editor will
inform the situation in the status line too.

  That's very useful when you are typing complex parenthetical expressions or
a very nested code. You can use it jointly with the `cmbSearchStart',
`cmbSearchEnd', `cmbSearchOpPar', `cmbSearchClPar', `cmbSearchOpCor' and
`cmbSearchClCor' commands. (*Note Miscellaneous::).


File: editor.inf,  Node: Syntax Highlight,  Prev: Match pair highlight,  Up: Editing Modes

4.9 Syntax Highlight
====================

  The editor can highlight the syntax of your code. The available modes are:

   * No highlight, all the code is with the same color.

   * C/C++ Highlight.

   * Pascal Highlight.

   * Clipper Highlight.

  The kind of highlight is chosen automatically in RHIDE using the extention
of the file.

  The C/C++ highlight was designed for the GNU C compiler.

  The Pascal highlight was designed for the GNU Pascal compiler.

  The Clipper highlight was designed for the CA-Clipper 5 compiler.


File: editor.inf,  Node: Calculator,  Next: How to contact me,  Prev: Editing Modes,  Up: Top

5 Calculator
************

  The calculator inside the editor was made by Laszlo Molnar. Laszlo is a
friend of mine from Hungary and is the author of the great DJP progam (a
djgpp exe's compressor).

  The sources of the calculator are in the `parser.c' file. They are free
and you can use it for any purpose.

  Here is the documentation of the calculator written by Laszlo:

  The purpose of this program, to provide a simple but powerful 'calculator'
for programmers, to help with coding and debugging, where GDB's expression
evaluator is not enough.

  You may say "Hey, I can write a better one with flex and bison", and you
may be right. I can make a better one too. But it'll be 4-5 times longer!
This calculator is only 10 kbytes of C code. What I think? It's not that
bad.

  The parser algorithm I use is called 'Operator Precedence Parsing' (I
translated this from Hungarian, so I may be wrong ;-). It works with
'operator precedence grammars' (a subset of LR(1) grammars), which means
that there can't be two non-terminating tokens next to each other on the
right side of your grammar rules. It's ideal for expression evaluation.

  With this parser you can use numbers, operators, parentheses and functions
like in C.

Here are the operators in decreasing precedence:

  1. `~' unary not `-' unary minus

  2. `**' power

  3. `*' multiplication `/' division `%' modulo

  4. `+' plus `-' binary minus

  5. `<<' shift left `>>' shift right

  6. `&' logical and

  7. `^' logical xor

  8. `|' logical or

  The calculator includes the following functions: sin\, cos\, tan\, sinh\,
cosh\, tanh\, asin\, acos\, atan\, log\, log10\, exp\, abs\, sqrt\, ceil
and floor.  They work as you expected.  Additionally the calculator
provides some radix conversion routines: bin\, oct\, dec and hex.

  The calculator uses doubles, but you can use numbers in the usual integer
formats also: 0x... for base 16, 0b... for base 2 and 0... for base 8.
The result of the calculation is displayed as a double for base 10, and
converted to long long format for the other radixes.

Error codes:

   * -1
     - Meaning: yylex()   failed e.g.  `1+#'

   * -3
     - Meaning: yyparse() failed e.g.  `1+2)'

   * -4
     - Meaning: floating point exception e.g. `sqrt(-1)'


File: editor.inf,  Node: How to contact me,  Next: Index,  Prev: Calculator,  Up: Top

6 How to contact me
*******************

  If you have any suggestions or bug report contact me at the address shown
in the author section. *Note About the Author::.

* Menu:

* Bugs::


File: editor.inf,  Node: Bugs,  Prev: How to contact me,  Up: How to contact me

6.1 Bugs
========

  If you find a bug please contact me, the Undo thing is the most complex
one and I know that needs some work on it.

  When reporting a bug please don't tell me: Some times some strange thing
happend ... Try to find a pattern to the problem. What situation triggers
the problem? ... with which file(s)? Then send me the file and the
description.

  When sending to me a file UUEncode it to avoid problems related with the
e-mail.


File: editor.inf,  Node: Index,  Next: Index of key commands,  Prev: How to contact me,  Up: Top

7 Index
*******

* Menu:

* Autoindent:                            Autoindent.
* Blocks:                                Blocks.
* Blocks - Rectangular:                  Rectangular Blocks.
* Bugs:                                  Bugs.
* Column cursor:                         Column cursor.
* How to contact me:                     How to contact me.
* Indentation:                           Indentation.
* Insert and Delete:                     Insert and Delete.
* Intelligent C indent:                  Intelligent C indent.
* keybind.cc:                            How to configure the keyboard.
* keybind.h:                             How to configure the keyboard.
* keybind.txt:                           How to configure the keyboard.
* Match pair highlight:                  Match pair highlight.
* Movement:                              Cursor movement.
* Overwrite:                             Overwrite.
* Persistent Blocks:                     Block modes.
* pmacros.txt:                           Pseudo Macros.
* Pseudo Macros:                         Pseudo Macros.
* Real Tabs:                             Real Tabs.
* Row cursor:                            Row cursor.
* scan codes:                            A program to find the scancodes.
* TABs:                                  Real Tabs.
* Use Real Tabs:                         Real Tabs.


File: editor.inf,  Node: Index of key commands,  Prev: Index,  Up: Top

8 Index of key commands
***********************

* Menu:

* Autoindent mode on/off <^O>:           Miscellaneous.
* Beginning of line <Home>:              Cursor movement.
* Bottom of file <^Q-C>:                 Cursor movement.
* Bottom of window <^Q-X>:               Cursor movement.
* Character left <Left arrow>:           Cursor movement.
* Character right <Right arrow>:         Cursor movement.
* cmbBackSpace <Backspace>:              Insert and Delete.
* cmbCharLeft <Left arrow>:              Cursor movement.
* cmbCharRight <Right arrow>:            Cursor movement.
* cmbClear <^Del>:                       Blocks.
* cmbCompactBuffer <From menu>:          Miscellaneous.
* cmbCopy <^Ins>:                        Blocks.
* cmbCopyBlock <^K-C>:                   Blocks.
* cmbCut <^K-Y>:                         Blocks.
* cmbDelChar <Del>:                      Insert and Delete.
* cmbDelEnd <^Q-Y>:                      Insert and Delete.
* cmbDelLine <^Y>:                       Insert and Delete.
* cmbDelPrevWord <^Backspace>:           Insert and Delete.
* cmbDelStart <^Q-H>:                    Insert and Delete.
* cmbDelWord <^T>:                       Insert and Delete.
* cmbEndSelect <^K-K>:                   Blocks.
* cmbExpandAllTabs <From menu>:          Miscellaneous.
* cmbExpandCode <^Space>:                Miscellaneous.
* cmbFirstLineInScreen <^Q-E>:           Cursor movement.
* cmbGoBeginBlock <^Q-B>:                Blocks.
* cmbGoEndBlock <^Q-K>:                  Blocks.
* cmbGotoEditorLine <^J>:                Miscellaneous.
* cmbGotoMarkn <^Q n*>:                  Miscellaneous.
* cmbHideSelect <^K-H>:                  Blocks.
* cmbIndentBlk <^K-Tab>:                 Indentation.
* cmbIndentBlkOne <^K-I>:                Indentation.
* cmbIndentMode <^O>:                    Miscellaneous.
* cmbInsMode <Ins>:                      Insert and Delete.
* cmbLastLineInScreen <^Q-X>:            Cursor movement.
* cmbLineDown <Down arrow>:              Cursor movement.
* cmbLineEnd <End>:                      Cursor movement.
* cmbLineStart <Home>:                   Cursor movement.
* cmbLineUp <Up arrow>:                  Cursor movement.
* cmbMarkLine <^K-L>:                    Blocks.
* cmbMarkWord <^K-T>:                    Blocks.
* cmbMoveBlock <^K+V>:                   Blocks.
* cmbNewLine <Enter>:                    Insert and Delete.
* cmbPageDown <PgDn>:                    Cursor movement.
* cmbPageUp <PgUp>:                      Cursor movement.
* cmbPaste <Shift+Ins>:                  Blocks.
* cmbPlayMacro <^F10>:                   Miscellaneous.
* cmbPutMarkn <^K n*>:                   Miscellaneous.
* cmbReadBlock <^K-R>:                   Blocks.
* cmbRecordMacro <Shift+F10>:            Miscellaneous.
* cmbReplaceSelect <Shift+^Ins>:         Blocks.
* cmbScrollDown <^Z>:                    Cursor movement.
* cmbScrollUp <^W>:                      Cursor movement.
* cmbSearchClCor <Shift+^]>:             Miscellaneous.
* cmbSearchClPar <Shift+^0>:             Miscellaneous.
* cmbSearchEnd <^]>:                     Miscellaneous.
* cmbSearchOpCor <Shift+^[>:             Miscellaneous.
* cmbSearchOpPar <Shift+^9>:             Miscellaneous.
* cmbSearchStart <^[>:                   Miscellaneous.
* cmbSelLength <^Q-L>:                   Blocks.
* cmbSelRectCopy <^K-Shift+C>:           Rectangular Blocks.
* cmbSelRectCut <^K-ShiftT>:             Rectangular Blocks.
* cmbSelRectDel <^K-Shift+L>:            Rectangular Blocks.
* cmbSelRectEnd <^K-Shift+K>:            Rectangular Blocks.
* cmbSelRectHide <^K-Shift+H>:           Rectangular Blocks.
* cmbSelRectMove <^K+Shift+V>:           Rectangular Blocks.
* cmbSelRectPaste <^K-Shift+P>:          Rectangular Blocks.
* cmbSelRectStart <^K-Shift+B>:          Rectangular Blocks.
* cmbSetGlobalOptions <Alt+G>:           Miscellaneous.
* cmbSetLocalOptions <Alt+L>:            Miscellaneous.
* cmbSmartIndent <^Tab>:                 Indentation.
* cmbSmartUnIndent <Shift+^Tab>:         Indentation.
* cmbStartSelect <^K-B>:                 Blocks.
* cmbStopMacro <Alt+F10>:                Miscellaneous.
* cmbTextEnd <^Q-C>:                     Cursor movement.
* cmbTextStart <^Q-R>:                   Cursor movement.
* cmbToLower <^K-O>:                     Blocks.
* cmbToUpper <^K-M>:                     Blocks.
* cmbUndo <Alt+Backspace>:               Miscellaneous.
* cmbUnIndentBlk <^K-Shift+Tab>:         Indentation.
* cmbUnIndentBlkOne <^K-U>:              Indentation.
* cmbWordLeft <^Left arrow>:             Cursor movement.
* cmbWordRight <^Right arrow>:           Cursor movement.
* cmbWriteBlock <^K-W>:                  Blocks.
* Compact the text using tabs <From menu>: Miscellaneous.
* Convert all tabs in spaces <From menu>: Miscellaneous.
* Convert to Lowercase <^K-O>:           Blocks.
* Convert to Uppercase <^K-M>:           Blocks.
* Copy the selected block <^K-C>:        Blocks.
* Copy to Clipboard <^Ins>:              Blocks.
* Copy to special Clipboard <^K-Shift+C>: Rectangular Blocks.
* Delete block <^Del>:                   Blocks.
* Delete block <^K-Shift+L>:             Rectangular Blocks.
* Delete block and copy it to an special Clipboard <^K-ShiftT>: Rectangular Blocks.
* Delete block and copy it to the Clipboard <^K-Y>: Blocks.
* Delete character to left <Backspace>:  Insert and Delete.
* Delete line <^Y>:                      Insert and Delete.
* Delete the character under cursor <Del>: Insert and Delete.
* Delete to end of line <^Q-Y>:          Insert and Delete.
* Delete to start of line <^Q-H>:        Insert and Delete.
* Delete word at left <^T>:              Insert and Delete.
* Delete word at right <^Backspace>:     Insert and Delete.
* End of line <End>:                     Cursor movement.
* Find place marker <^Q n*>:             Miscellaneous.
* Goto Line <^J>:                        Miscellaneous.
* Hide/Show block <^K-H>:                Blocks.
* Hide/Show block <^K-Shift+H>:          Rectangular Blocks.
* Indent block <^K-Tab>:                 Indentation.
* Indent block one position adding a space <^K-I>: Indentation.
* Insert line <Enter>:                   Insert and Delete.
* Insert mode on/off <Ins>:              Insert and Delete.
* Line down <Down arrow>:                Cursor movement.
* Line up <Up arrow>:                    Cursor movement.
* Mark line <^K-L>:                      Blocks.
* Mark word <^K-T>:                      Blocks.
* Move block <^K+Shift+V>:               Rectangular Blocks.
* Move block <^K+V>:                     Blocks.
* Move to beginning of block <^Q-B>:     Blocks.
* Move to end of block <^Q-K>:           Blocks.
* Page down <PgDn>:                      Cursor movement.
* Page up <PgUp>:                        Cursor movement.
* Paste from Clipboard <Shift+Ins>:      Blocks.
* Paste from special Clipboard <^K-Shift+P>: Rectangular Blocks.
* Play a macro <^F10>:                   Miscellaneous.
* PMacro's Trigger <^Space>:             Miscellaneous.
* Read block from disk <^K-R>:           Blocks.
* Replace the block by the Clipboard block <Shift+^Ins>: Blocks.
* Report the length of the block <^Q-L>: Blocks.
* Scroll the screen one line down <^Z>:  Cursor movement.
* Scroll the screen one line up <^W>:    Cursor movement.
* Search the ( where the cursor is <Shift+^9>: Miscellaneous.
* Search the ) where the cursor is <Shift+^0>: Miscellaneous.
* Search the [ where the cursor is <Shift+^[>: Miscellaneous.
* Search the ] where the cursor is <Shift+^]>: Miscellaneous.
* Search the close curly bracket where the cursor is <^]>: Miscellaneous.
* Search the open curly bracket where the cursor is <^[>: Miscellaneous.
* Set beginning of block <^K-B>:         Blocks.
* Set beginning of block <^K-Shift+B>:   Rectangular Blocks.
* Set end of block <^K-K>:               Blocks.
* Set end of block <^K-Shift+K>:         Rectangular Blocks.
* Set marker <^K n*>:                    Miscellaneous.
* Set the default options (Not in RHIDE) <Alt+G>: Miscellaneous.
* Set the options of the current window (Not in RHIDE) <Alt+L>: Miscellaneous.
* Smart Indent block <^Tab>:             Indentation.
* Smart Unindent block <Shift+^Tab>:     Indentation.
* Start recording a macro <Shift+F10>:   Miscellaneous.
* Stop recording a macro <Alt+F10>:      Miscellaneous.
* Top of file <^Q-R>:                    Cursor movement.
* Top of window <^Q-E>:                  Cursor movement.
* Undo <Alt+Backspace>:                  Miscellaneous.
* Unindent block <^K-Shift+Tab>:         Indentation.
* Unindent block one character - not an x position <^K-U>: Indentation.
* Word left <^Left arrow>:               Cursor movement.
* Word right <^Right arrow>:             Cursor movement.
* Write block to disk <^K-W>:            Blocks.



Tag Table:
Node: Top399
Node: Introduction929
Node: What is SETs Editor?2484
Node: Requirements3321
Node: About the Author3579
Node: Available commands4852
Node: Conventions5561
Node: Cursor movement6739
Node: Insert and Delete8440
Node: Blocks9833
Node: Block modes12063
Node: Selecting with the mouse or Shift13165
Node: Using the mouse13561
Node: Using the Shift key13963
Node: Indentation14338
Node: Rectangular Blocks16519
Node: Pseudo Macros17877
Node: Please enlighten me - what is that?18233
Node: How can I customize that?19408
Node: Miscellaneous21414
Node: Keyboard23184
Node: How to configure the keyboard23634
Node: A program to find the scancodes27067
Node: Editing Modes27887
Node: Overwrite28521
Node: Autoindent28833
Node: Real Tabs29183
Node: Persistent Blocks31403
Node: Intelligent C indent31681
Node: Can you explain to me more about the behavior of this mode?33821
Node: Do you have more examples?36954
Node: Column cursor38950
Node: Row cursor39465
Node: Match pair highlight39785
Node: Syntax Highlight40630
Node: Calculator41260
Node: How to contact me43623
Node: Bugs43898
Node: Index44432
Node: Index of key commands45900

End Tag Table
