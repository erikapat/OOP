START-INFO-DIR-ENTRY
* RHIDE: (rhide.inf).   Documentation about RHIDE, an IDE for DJGPP or Linux.
END-INFO-DIR-ENTRY

This is the documentation for the Integrated Development Environment RHIDE.

Copyright (C) 1996,1997 Robert H”hne

This documentation may be freely distributed with the RHIDE package or any
part thereof, provided this copyright notice is left intact on all copies.

RHIDE
*****

   Table of Contents
   *****************
1. Introduction
  1.1 Copying
  1.2 Installing RHIDE
  1.2.1 Configuring RHIDE
  1.3 What is RHIDE?
  1.4 Requirements
  1.5 Getting started
  1.5.1 Supported languages
  1.5.2 Debugging RHIDE
  1.6 The program GPR2MAK.EXE
  1.7 First steps with RHIDE
  1.7.1 What are these so called projects
  1.7.2 Creating your first project
  1.8 Environment variables
  1.8.1 Setting environment variables for RHIDE
  1.8.2 Where to store the environment file
2. General information about how RHIDE works
  2.1 Known suffixes
  2.2 Syntax of arguments
  2.3 Running under Windows 95
  2.4 Running under OS/2
  2.5 Running under Windows NT
  2.6 Running under Linux
  2.7 General use of RHIDE
  2.7.1 Creating a program
  2.7.1.1 Creating a program without a project
  2.7.2 Creating a library
  2.7.3 Saving/Loading the options
3. Description of the pull-down menus
  3.1 System menu
  3.1.1 About
  3.1.2 Bug report
  3.1.3 FSDB
  3.1.4 GREP
  3.1.5 GDB
  3.1.6 Refresh Desktop
  3.1.7 Calculator
  3.1.8 Puzzle
  3.1.9 Calender
  3.1.10 ASCII table
  3.2 File
  3.2.1 Open
  3.2.2 New
  3.2.3 Save
  3.2.4 Save as
  3.2.5 Save all
  3.2.6 DOS Shell
  3.2.7 Exit
  3.3 Edit
  3.3.1 Undo
  3.3.2 Redo
  3.3.3 Cut
  3.3.4 Copy
  3.3.5 Paste
  3.3.6 Show Clipboard
  3.3.7 Clear
  3.3.8 Copy to Windows clipboard
  3.3.9 Paste from Windows clipboard
  3.3.10 Expand all tabs
  3.3.11 Compact text
  3.3.12 Macro
  3.3.12.1 Record
  3.3.12.2 Stop
  3.3.12.3 Play
  3.4 Search
  3.4.1 Find
  3.4.2 Replace
  3.4.3 Search again
  3.4.4 Goto line
  3.4.5 Jump to function
  3.4.6 Next message
  3.4.7 Previous message
  3.5 Run
  3.5.1 Run
  3.5.2 Step over
  3.5.3 Trace into
  3.5.4 Go to cursor
  3.5.5 Program reset
  3.5.5.1 Main function
  3.5.6 Arguments
  3.6 Compile menu
  3.6.1 Compile
  3.6.2 Make
  3.6.3 Link
  3.6.4 Build all
  3.7 Debug
  3.7.1 Set/Reset Breakpoint
  3.7.2 Evaluate/Modify
  3.7.3 Watch an expression
  3.7.4 Breakpoints
  3.7.5 Disassembler window
  3.7.6 Call stack
  3.7.7 List of Functions
  3.8 Project
  3.8.1 Open project
  3.8.2 Close project
  3.8.3 Add item
  3.8.4 Delete item
  3.8.5 Local options
  3.8.6 Includes
  3.8.7 Main targetname
  3.8.8 Primary file
  3.8.9 Clear dependencies
  3.8.10 Delete rebuildable files
  3.8.11 Write Makefile
  3.9 Options
  3.9.1 Directories
  3.9.1.1 Include directories
  3.9.1.2 Library directories
  3.9.1.3 Object directories
  3.9.1.4 Sources directories
  3.9.1.5 Standard headers
  3.9.2 C/C++-Compiler
  3.9.2.1 Warnings
  3.9.2.2 Optimizations
  3.9.2.3 Debugging
  3.9.2.4 C options
  3.9.2.5 CXX options
  3.9.2.6 Pascal options
  3.9.2.7 Fortran options
  3.9.2.8 How to toggle these flags
  3.9.3 Libraries
  3.9.4 Linker options
  3.9.5 Compiler options
  3.9.6 Environment
  3.9.6.1 Colors
  3.9.6.2 Editor options
  3.9.6.3 Preferences
  3.9.6.4 Mouse options
  3.9.6.5 Reserved words
  3.9.6.6 Pascal reserved words
  3.9.6.7 C-Flags
  3.9.6.8 CXX-Flags
  3.9.6.9 Pascal-Flags
  3.9.6.10 Fortran-Flags
  3.9.6.11 Warning-Flags
  3.9.6.12 Debugging-Flags
  3.9.6.13 Optimization-Flags
  3.9.6.14 User words
  3.9.7 Save options
  3.9.8 Load options
  3.10 Windows
  3.10.1 Size/move
  3.10.2 Zoom
  3.10.3 Tile
  3.10.4 Cascade
  3.10.5 Next
  3.10.6 Previous
  3.10.7 Close
  3.10.8 List
  3.10.9 Project
  3.10.10 UserScreen
  3.11 Help
  3.11.1 Help
  3.11.2 RHIDE Help index
  3.11.3 Syntax help submenu
  3.11.3.1 Syntax help
  3.11.3.2 Files to search
  3.11.3.3 Options for searching
  3.11.4 Index for syntax help
  3.11.5 libc reference
  3.11.6 Help about help
4. Detailed description of some parts of RHIDE
  4.1 Selecting a window
  4.2 How the editor works
  4.2.1 Erasing commands
  4.2.2 Cursor moving commands
  4.2.3 Text selecting and searching commands
  4.2.4 Block commands
  4.2.5 Other commands
  4.3 Some hints and problems
  4.3.1 Problems with automatic dependencies
  4.4 Project window
  4.4.1 Items of your project
  4.4.2 Open a project item
  4.4.3 Dependencies of project item
  4.4.4 Local options for a project item
  4.5 Builtin compiler specs
  4.6 Builtin variables
  4.7 Change the defaults of RHIDE
  4.8 Message window
  4.9 Syntax highlighting
  4.10 Checking the dependencies
  4.11 What is Turbo Vision
  4.12 How the dialogs work
  4.13 Defining macros
  4.14 The INFO Viewer
  4.15 RCS and RHIDE
5. Debugging with RHIDE
  5.1 Limitations of the integrated debugger
  5.2 Dual display debugging
  5.3 Using the integrated debugger
  5.3.1 Stepping through the source code
  5.3.2 Evaluating the contents of variables
  5.3.3 Watching the contents of variables
  5.4 Problems with C++ programs
  5.5 Using Breakpoints
  5.5.1 Setting a breakpoint
  5.5.2 Modifying and setting a breakpoint
  5.5.3 Problems with breakpoints
6. Debugging with RHGDB
7. Some FAQs
8. Index
9. Index of key commands

1. Introduction
***************

1.1 Copying
===========


RHIDE is copyright by Robert H”hne.
Parts of RHIDE are copyright by other people as noted in the
source files.

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

Additional conditions:

If you make any modifications on RHIDE, you have to leave the original
copyright notice intact and add an comment about your modifications.

If you distribute the binaries for RHIDE from modified sources, then
you have to add a notification which is printed at startup of RHIDE
and in the about box to tell the user that you have made modifications
and that it is not the binary from the original sources distributed by me.

If you distribute the sources for RHIDE, you are not allowed to distribute
the full modified sources for the Turbo Vision library because of the
copying conditions by Borland International.

If you want to include RHIDE (binaries and/or sources) in a commercial
product (on a CD-ROM for a book or something else) contact me first.

For contacting the author send electronic mail to

Robert.Hoehne@Mathematik.TU-Chemnitz.DE

(valid until at least 30. September 1997)

or paper mail to

Robert H”hne
Am Berg 3
D - 09573 Dittmannsdorf
Germany

1.2 Installing RHIDE
====================

There are two archives

`rhide??b.zip'
     This contains the executables and the documentation for RHIDE running on
     DJGPP

`rhide-?.?-1.i386.rpm'
     This is a RPM package with the binaries of RHIDE for Linux.

`rhide??s.zip'
     This contains the sources of RHIDE for DJGPP.

`rhide-?.?-1.src.rpm'
     This is a RPM package with the sources of RHIDE for Linux.

NOTE: The sources for the Linux and DJGPP versions are of course in its core
the same, there are only differences in the text-file formats (CR or CR/LF)
and the project files differ and the DJGPP sources contain some additional
patches for the libc library to fix some known bugs there. But in general
both archives can be used on both systems (after some cosmetic changes).

where `??' in the above filenames stand for the digits of the actual version
of RHIDE.

These archives can be found at The RHIDE home page, at this URL:

     http://www.tu-chemnitz.de/~rho/rhide.html

(valid until at least 30. Sepetember 1997) or at any ftp site, which mirrors
DJGPP.

The RPM packackes can be found at sunsite mirrors and/or also in some Linux
distributions.

To install these archives, unzip them in the DJGPP-root directory, like any
other DJGPP package.

To install the Linux RPM packages, use your favotite install program (most
Linux distributions allow to install RPM packages) or install it with the
Redhat package manager itself.

1.2.1 Configuring RHIDE
-----------------------

In most cases do nothing to configure RHIDE. But there are some special
things, which must be configured which have mostly to do with the editor (or
better) the keyboard layout.

The editor of RHIDE is configurable for the keyboard. For this it uses a text
file `keybind.txt', which is searched in the following directories (in that
order). If it was not found in any of these directories RHIDE uses builtin
defaults. For more information about creating (customizing) the file and
about the syntax of that file See Documentation about the keyboard in "SET's
editor", or point your Web browser to http://editor.html

   * The current directory

   * The contents of the variable `$(RHIDE_SHARE)' it is set.

   * The contents of the variable `$(HOME)' it is set.

   * `%DJDIR%/share/rhide'

The binary archive of RHIDE includes already the config files for the US
keyboard layout (`us.txt') and many others, which are based on the Linux
keytables. If you have problems with the keyboard layout try to copy one of
the files to `keybind.txt' (probably the one, which has a name similar to
your country).

RHIDE also contains the file `keybind.txt' which IS `us.txt'.

As an example, if you are are using a German keyboard, and you have installed
`keyb.com' as your keyboard driver program, you need to copy `de.txt' to
`keybind.txt' otherwise (for example) the keys <y> and <z> are exchanged.

If you are using a keyboard driver (like I), which converts the scancodes of
the keys (`keyb.com' does that NOT) you will probably not need the file
`de.txt' (but the default `keybind.txt').

For configuring RHIDE on Linux (especially when running under X) See Section
2.6

1.3 What is RHIDE?
==================

What is RHIDE? RHIDE is an Integrated Development Environment for compiling
C- or C++-files (GNU-Assembler source files also supported) in an
environment, which has an integrated editor where you can edit your source
files and a project management, where you can define, which files are needed
to build a program or a library.

For what stands the name RHIDE? This has nothing mystic in it. It comes
simply from my initials RH and IDE (Integrated Development Environment).

RHIDE works like the IDE from Borland, which comes with Turbo C++ 3.1 and is
written with the Turbo Vision library, which I have ported to use with DJGPP.
Features of this IDE are:
   - Syntax highlighting is now supported and you can customize all colors on
     your desktop.

   - You can redirect the stdout and stderr from your program to a window in
     the IDE.

   - You can generate a makefile for your project, so you can build the
     program also without the IDE.

   - Most of the commandline options of GCC can be customized.

   - You can also build a library instead of an executable.

   - When saving a file to disk, the modification time of this file will be
     set to the time of the last modification in the editor.

   - You can interrupt external programs (the compilers or your program) by
     pressing <Ctrl+C> or <Ctrl+Break> which are ignored by the IDE. That
     means also, that you cannot interrupt the IDE by pressing these keys. If
     you want to enable this, compile the IDE without the `-DNO_BREAK'-flag.

   - The integrated debugger. You can debug your program within RHIDE by
     executing each source line of your code and evaluating/modifying
     variables and expressions.

   - You can define another compiler to compile your source files.

In addition to RHIDE I have included a stand-alone debugger (called
`rhgdb.exe'), which is GDB 4.16 with a Turbo Vision user interface.

1.4 Requirements
================

RHIDE works under and is compiled with DJGPP V2.01.  To compile your programs
you need a working GCC-configuration, that means, GCC must be found in your
path. Because DJGPP works only under DPMI you need a DPMI-Server.  If you run
it under Windows 3.1(1)/95, you have DPMI. Under MS-DOS you need either a
memory-manager, which give you DPMI-services (I think QEMM is it, EMM386 has
no DPMI-support), or you use CWSDPMI, the free DPMI-server from Charles W.
Sandmann, which you can find on SimTel-ftp-sites. I use it and it works fine
for me.

The builtin editor uses a simple heuristic to check, if a file is in UNIX or
DOS text format. It checks the first 1024 Bytes, and if there is a lf without
a cr, all lf's will be translated to cr/lf's. This is done at first only in
memory. But if you save your file to disk, it will be saved in DOS text
format.

RHIDE will work correctly only with DJGPP version 2.01 or higher. If you have
installed DJGPP 2.0, you will run into problems when the commandline passed
to the called compilers or the linker will exceed the 126 character limit.
There is a new technique used from DJGPP 2.01 on, which programs compiled
under 2.0 don't understand.

1.5 Getting started
===================

To run RHIDE type
     rhide [options] ['file-name']
or
     rhide [options] 'project-name' [options]
Here stands 'file-name', for a file, which you want to open at start up.  If
it has no suffix it is assumed to be a 'project-name'.

'project-name' stands for a name of your project. If you don't type it, RHIDE
searches the current directory for a project file. If there exists only one,
it will be opened. If there exist more than one or none, RHIDE will not open
a project, you have to do it manually.  (See Section 3.2.1 project)

Possible options are for debugging RHIDE itself (See Section 1.5.2).  If no
project was open, you will see an empty desktop.  At the top-line of the
screen you can see the menu. This is activated by pressing <F10> or by
clicking with the mouse at this line.  Alternatively you can press <Alt> plus
the highlighted character of a pull-down menu, e.g. to activate the *File*
menu, press `Alt+F'. At the bottom is the status line with some hotkeys and
their functions displayed.

Other options are:

`-H'
     Do not install the console switch handler, which saves/restores the
     modified keyboard layout. This options works only when running under
     Linux.

`-S'
     Tells RHIDE to use only 16bit access to the video memory under DJGPP,
     becuase some video cards cannot handle the 32bit access.

`-E'
     Dump all variables known to RHIDE (the builtins and the real environment
     variables) to `stderr' end exit.

`-C'
     Disable the handling of SIGINT

`-y'
     Use long filenames (only under Windows 95)

`-n'
     Do not use long filenames (only under Windows 95)

`-c'
     Do not convert the case of any file name

`-h'
     Show a short help about all the possible options.

`-b'
     Use BIOS calls for setting and resetting the behavior of the 7th bit in
     a color attribute (blinking or 16 background colors) instead of direct
     outputs to the VGA registers.

`-k KEY_FILE'
     The editor in RHIDE is now configurable also for the keyboard.  The
     file, where the key bindings are stored, is searched at first in the
     current directory; then in the directory `%DJDIR%/data'; and then in the
     directory where the executable is. If all this fails default values are
     taken.

     With this switch you can override the default name of `keybind.txt' to
     whatever you want.

`-p'
     Normally RHIDE converts all the num-pad keys to the equivalent keys on
     the other keyboard (of course also by checking the <NumLock> key). With
     this switch you can disable this.

`-G n'
     Select which method is used for swapping the display. Currently there
     are two, little different functions implemented.  If you have problems
     with display swapping when in graphics mode, try to use another method
     and see if that helps.

`-K'
     Tell RHIDE, to use real BIOS calls for it's keyboard input. This is
     needed sometimes, when you have installed some special keyboard drivers.

`-M'
     This tells RHIDE to not to install the mouse callback function for
     getting the mouse events. Instead of this RHIDE calls the mouse BIOS
     functions for getting any event of the mouse. This option should be used
     mainly when running under Windows NT (but there I select this now
     automatically by default)

At the upper right corner of the screen you can see the free virtual/physical
memory (where M stands for Megabytes, K for Kilobytes and B for Bytes), if
enabled (See Preferences).

If you try to open a project, which does not exist, RHIDE will create a new
one.  The way for creating a new project is done by RHIDE as follows.  If
there exist in the directory of RHIDE (usually in %DJDIR%/bin) a project file
with the root name of the executable and the suffix `.gpr', this file is
copied as your new project file with all customizations, which you have done
in it. If this standard project file doesn't exist, a new project file is
created with the hardcoded defaults.

To create such a standard project file, change to the directory where the
executable is and call the exe-file with the argument of its name without the
suffix `.exe'. After leaving the program, the standard project file is
created.

1.5.1 Supported languages
-------------------------

There is also support for multiple languages. For this RHIDE uses the GNU
gettext library. With this lib it is possible to support multiple languages
without changing any code of RHIDE, when adding a new language.

There are two ways for selecting the language. Either you set the environment
variable LANGUAGE to the language you want or give it as a commandline
argument to RHIDE. The normal way is by setting LANGUAGE. If you have
installed RHIDE as described in the `readme', you should specify the language
with a two character shortcut. Here is the list of the current supported
languages together with the two character code:

`da'
     Danish maintained by Erik Bachmann <ebp@dde.dk>

`de'
     German maintained by Robert H”hne
     <Robert.Hoehne@Mathematik.TU-Chemnitz.DE> (valid until at least 30.
     September 1997)

`es'
     Spanish maintained by Salvador Eduardo Tropea (SET) <ice@inti.edu.ar>

`fi'
     Finnish maintained by Jari Anttonen <janttone@iwn.fi>

`fr'
     French maintained by Eric Nicolas <nicolas@dsys.ceng.cea.fr>

`it'
     Italian maintained by Normando Marcolongo <i094968@spv.ing.uniroma1.it>

`nl'
     Dutch maintained by Martijn Laan <mlaan@cs.vu.nl>

`pt'
     Portuguese maintained by Goncalo Farias <mad@telepac.pt>

`sv'
     Swedish maintained by Christian Axbrink <sa9471@ida.utb.hb.se>

When you want to specify the language on the commandline, use the following
syntax:
     rhide -L LANGUAGE
where LANGUAGE represents the language code.

If you do not specify any language, English is assumed.

Because it was not possible to get all the translations at the time when
RHIDE was ready, I included only the message files (that are the files with
the `.mo' suffix) as they are ready in the binary archive. That means that it
is possible that you will see some strings in English instead of your
language.

1.5.2 Debugging RHIDE
---------------------

I have added some commandline options to debug the IDE itself. These options
are the following:

`-dt'
     Do not remove the temporary files which the IDE creates. The names of
     these files will be printed to stderr.

`-dc'
     Print to `stderr' the commands which the IDE executes.

`-dd'
     Print to `stderr' how the IDE checks the dependencies.

`-df'
     Print to `stderr' how the IDE searches for files.

`-ds'
     Print to `stderr' how the IDE expands the specs.

`-da'
     Turns on all of the above

You can also combine these options like `-dct', which is the same as `-dc
-dt'.

To examine this debugging information, it is the best to use the redir
command, to redirect the stderr to a file like
     redir -e err rhide -da project
which will redirect stderr to the file `err'.

Each of the letters above (after `-d') can be prefixed by a `-' or a `+' to
explicitely turn the flag on or off.  For instance `-dc' and `-d+c' are the
same and `-da-c' selects all debugging options except the `-dc' switch.

If you want to supply certain switches for RHIDE as a default, you may put
them into the environment variable `$(RHIDEOPT)'.  The contents of this
variable is used before the the real commandline is parsed.  That means you
can overwrite the switches from the environment variable.

1.6 The program GPR2MAK.EXE
===========================

This program can be used to create a makefile from your project-file.  It
does exactly the same as the function which is selectable from the RHIDE menu
(See Section 3.8.11).

In RHIDE you have only the possibility to say, if in the generated makefile
all dependencies should be included or not. With `gpr2mak.exe' you can tell
also to create recursively all the needed makefiles. This makes sense only if
you have included other projects in your project.

Here are the possible commandline options for `gpr2mak.exe'.
`-d'
     Include all dependencies in the makefile

`-d-'
     Include only the needed dependencies to create the final program or
     library.

`-r'
     Call `gpr2mak.exe' recursively, if there are other projects part of the
     project.

`-r-'
     Do not call `gpr2mak.exe' recursively.

`-o OUTFILE'
     Use `OUTFILE' instead of the project name (with the suffix `.mak') as
     the created makefile. If you want to write the makefile to `stdout', use
     `-' as `OUTFILE'.

And the complete syntax for calling `gpr2mak.exe' is also:

     gpr2mak.exe [-d[-]] [-r[-]] [-o OUTFILE] project-file

If you give no options, (the project-file must be given), `gpr2mak.exe'
assumes the flags `-d- -r-' as default.

1.7 First steps with RHIDE
==========================

Here I will give you some instructions for the first steps to get contact
with RHIDE.

1.7.1 What are these so called projects
---------------------------------------

A project for RHIDE is a file, which contains all the needed information
required to build a program or library from one or more source files. Also
all the other options which belong to the look and feel of your desktop are
stored there.

In general RHIDE creates for each project two files. One for the project
itself (it has the suffix `.gpr') and one for the desktop related things (it
has the suffix `.gdt').

To create a new project either run rhide with a not existing project name as
argument or open within RHIDE a project by selecting a name which is not
existent.

1.7.2 Creating your first project
---------------------------------

For the next instructions I will assume, that you want to create a project
for the standard "Hello world" program in the current directory. Create now
the new project by running

     rhide hello

and you will see an empty desktop and one window opened, the project window.
This window will show you that there is no file defined for your project.  If
the project window is selected, (it has a double frame), then hit there <Ins>
and you will be prompted for adding an item to your project.

Type in the input line now `hello.c' and hit <ENTER>. Now hit <ESC> to leave
the dialog. You will see now, that the project window contains a line with
`hello.c'.

Now hit <ENTER> on that filename and you will get an empty editor window
named `hello.c' prepended by the current directory. In this editor window you
can type now the program:

#include <stdio.h>

int main()
{
  printf("Hello world!\n");
  exit(0);
}

Now you can select from the Run-menu the Run entry (or use the hotkey
`Ctrl+F9') and RHIDE will do all the necessary steps to compile, link and
execute the program.

If everything was correct (no typing errors) or some other error, you will
get a message box where RHIDE tells you, that the program exited with an exit
code of 0. (This is the value, which you have specified in your program above
in the `exit(0);' statement) This box you can close with <ENTER> or <ESC>.

To see the output of the program, you can switch now to the user screen with
`Alt+F5' or from the menu (Windows/User screen).  To return back to RHIDE hit
any key.

1.8 Environment variables
=========================

RHIDE uses many environment variables for it's configuration and behavior.
This includes also some standard variables, which are used by the in RHIDE
linked libraries. These are:

$(LOCALEDIR)
     This should point to the directory, where your locale files are stored.
     If it is not set, RHIDE tries to get the system default value, which is
     for Linux `/usr/share/locale' and for DJGPP `$(DJDIR)/share/locale'.

$(INFOPATH)
     This is a pathlist of directories, where your INFO files are stored. If
     not set, RHIDE tries the standard directory, which should for Linux
     `/usr/info' and for DJGPP `$(DJDIR)/info'.

$(RHIDEOPT)
     This variable can be used, to define global RHIDE commandline options.
     The value of this variable is used, as if the contents are given on
     commandline before any of the real commandline options. Which means,
     they can be overwritten on the commandline.

$(ESCDELAY)
     This variable is used *ONLY* in the Linux version, where it defines the
     delay after pressing <ESC> to wait for another keypress to simulate an
     <Alt> keycode. The value is given in milliseconds and defaults to 1000.

$(LANGUAGE)
     This variable is used to specify the language, in which RHIDE should
     communicate with you. The contents of this variable should be the ISO
     2-character code of your country.

$(RHIDE_SHARE)
     With this variable you can tell RHIDE where it should look at first for
     it's configuration files.

1.8.1 Setting environment variables for RHIDE
---------------------------------------------

There are some different ways for setting environment variables for RHIDE.
One of them is to set them like any other environment variable on your
system. But this means that these variables are visible also by all the other
programs.

When using the DJGPP version, you can set them in your `djgpp.env' file
either at the beginning as global variables for any DJGPP program or in a
special section `[RHIDE]' only for RHIDE. Please read the doc about the
format of the `djgpp.env' file for more information.

Derived from the technique used on DJGPP for setting environment variables
which are visible only for DJGPP programs, I have added in RHIDE a similar
thing. RHIDE can read environment variables also from a file called
`rhide.env'.

The syntax of this file is very simple. Each line has one of the following
syntax:
VARIABLE=CONTENTS
     Which means, that the environment variable `VARIABLE' should become the
     contents `CONTENTS' where `CONTENTS' can be also a variable, which is
     expanded at runtime.

.OTHER_ENV_FILE
     Such a line (it begins with a dot) tells RHIDE to read in at that point
     the file `OTHER_ENV_FILE' as environment file. The name `OTHER_ENV_FILE'
     can be also an environment variable, which is expanded before reading
     the file.

# comments
     A line, which begins with a `#' means, that this line is ignored.  It
     can be used for you to write there some comments about that file.

!VARIABLE=CONTENTS
     This is the same syntax as without the ! at the beginning of the line
     but it tells RHIDE to place the variable also in the environmen so also
     other programs (called by RHIDE) can see this variable.

RHIDE is very powerful in handling the environment variables. Most of it is
taken from the behavior of GNU make. On this great things depend, that a
variable name can consist also of other variables, which are computed when
the variable should be expanded.

As an example of this, you can take a look on the RHIDE sources in the
`rhide.env' files. There I'm using, for instance, the RHIDE builtin variable
$(RHIDE_OS) to define the libraries, which are linked in RHIDE depending on
the operating system where RHIDE is built.

An other example is distributed with RHIDE in it's binary archives as
`rhide_.env' which is commented and should be in a directory
`.../share/rhide/' where the `...' stand for a different directory on
different OS's. (on DJGPP it is %DJDIR% and on Linux it is /usr/local )

Here is a part of the environment file `rhide.var' in the main RHIDE source
directory (which is included by `rhide.env' with
.$(RHIDESRC)/rhide.var

RHIDE_OS_LIBS_Linux=ncurses gpm m
RHIDE_OS_LIBS_DJGPP_idegc.exe=dbg
RHIDE_OS_LIBS_DJGPP=$(RHIDE_OS_LIBS_DJGPP_$(MAIN_TARGET))
RHIDE_OS_LIBS=$(RHIDE_OS_LIBS_$(RHIDE_OS))

The RHIDE builtin linker spec (See Section 4.5) includes also
$(RHIDE_OS_LIBS) when linking. Since RHIDE can be built on DJGPP and Linux
and on these different operating systems I have to link different libraries.

Description of the above: When linking on DJGPP the file `idegc.exe' (which
is RHIDE) I have to include (in addition to all the other libraries)
`libdbg.a', which contains all the DJGPP specific debugging functions. This
is done at runtime by expanding RHIDE_OS_LIBS. Here are the steps, how RHIDE
expands the variable RHIDE_OS_LIBS:

$(RHIDE_OS_LIBS)                      ->  $(RHIDE_OS_LIBS_$(RHIDE_OS))
$(RHIDE_OS_LIBS_$(RHIDE_OS))          ->  $(RHIDE_OS_LIBS_DJGPP)
$(RHIDE_OS_LIBS_DJGPP)                ->  $(RHIDE_OS_LIBS_DJGPP_$(MAIN_TARGET))
$(RHIDE_OS_LIBS_DJGPP_$(MAIN_TARGET)) ->  $(RHIDE_OS_LIBS_DJGPP_idegc.exe)
$(RHIDE_OS_LIBS_DJGPP_idegc.exe       ->  dbg

In a similar way it expands on Linux to

$(RHIDE_OS_LIBS) -> ncurses gpm m

1.8.2 Where to store the environment file
-----------------------------------------

RHIDE searches some known directories for the file `rhide.env' (and of course
also other there defined included files).

At first it searches for a global file in `/usr/local/share/rhide' (on Linux)
or `$(DJDIR)/share/rhide'. Then it searches in `$(HOME)' and at last in the
current directory.

RHIDE does not only a search, it also loads the file, if it was found in any
of the above mentioned directories. That means, if in all these directories
`rhide.env' exists, it is loaded. This has the effect, that you can define
some global defaults which can be overwritten with a `rhide.env' in the
current or your home directory.

2. General information about how RHIDE works
********************************************

In this section I will give you some comments about the concept of RHIDE.
RHIDE works with the GNU compilers. As a result of this, most of the options
are fixed and they are mostly also specific only for this compiler. If I
speak about compilers, I mean GCC, which calls the right compilers for you.
(`cpp' for preprocessing your input files, `cc1' for compiling C programs,
`cc1plus' for compiling C++ programs and `as' for compiling assembler files
and so on)

Selecting the right compiler for a specific file is done by RHIDE in the same
way as GCC does it. It looks for the extension of the file and determines the
language of this file.

2.1 Known suffixes
==================

The list of the known suffixes is taken from GCC. Remember the fact, that GCC
and RHIDE check the suffixes in a case sensitive way especially when running
under Windows 95 (See Section 2.3).

   * Valid suffixes for C source files are
    `.c'
          Normal C source file

    `.i'
          C source file, which doesn't need the preprocessor

   * Valid suffixes for C++ source files are
    `.cc'
    `.cpp'
    `.cxx'
    `.C'
          Normal C++ source file

    `.ii'
          C++ source file, which doesn't need the preprocessor

   * Valid suffixes for Objective C source files
    `.m'
          Normal Objective C source file

   * Valid suffixes for Pascal source files
    `.p'
    `.pas'
          Normal Pascal source file

   * Valid suffixes for object files
    `.o'
          Normal object file

    `'
          any other suffix, which has no predefined meaning

   * Valid suffixes for libraries
    `.a'
          Normal library file

   * Valid suffixes for executable files
    `.exe'
          Normal executable file for MS-DOS

    `.'
          No suffix means the raw COFF image of an executable file. These can
          be handled only by programs, which know about this format.  (DJGPP
          programs know this)

   * Valid suffixes for include files
    `.h'
          Normal include files

    `.hpp'
          Some people told me, that this suffix should also be treated as a
          valid suffix for header files, so I applied it.

    `'
          Theoretically there is no restriction for such a suffix, but RHIDE
          searches and finds only files with the above suffixes in the
          specified directories (See Section 3.9.1.1)

   * Valid suffixes for Assembler source files
    `.s'
          Normal Assembler source file

    `.S'
          Assembler source file, which must be preprocessed by `cpp'. If you
          have such files, there is a problem, when long filenames are not
          enabled (default in MS-DOS), because RHIDE converts all filenames
          in this situation to lower case. But you can add to the local
          options for this item (See Section 3.8.5) the commandline argument
          -X ASSEMBLER-WITH-CPP, to tell `GCC' to preprocess this file first
          before assembling it.

   * Valid suffixes for Fortran source files
    `.f'
    `.for'
          Normal Fortran source files

    `.F'
    `.fpp'
          Fortran source files which need not to be run through `cpp'.

   * Valid suffixes for ADA source files
    `.adb'
          Normal ADA source file

    `.ads'
          ADA specs file

   * Valid suffixes for NASM
    `.nsm'
    `.asm'
          Normal NASM source files.

2.2 Syntax of arguments
=======================

In RHIDE you can specify some arguments to other programs. These arguments
must be a space separated list of strings. If you want to have one or more
spaces as part of an argument, you have to enclose the whole argument in
single or double quotes.

2.3 Running under Windows 95
============================

With DJGPP 2.01 were many bugs fixed, which caused problems under Windows 95
with the long (and case sensitive) filenames. Now all filenames are shown in
lower case, except they contain characters with different case. That means,
all normal 8+3 DOS filenames, which are normally reported in Windows 95 in
upper cases, are automatically converted to lower case. For more information
about filename conversion look at the libc reference.

If you really need the filenames exactly as they are reported by the OS, you
can use the -C switch (See Section 1.5).

You can also run more than one instance of RHIDE at once, in several
DOS-boxes, because RHIDE creates and uses its own temp directory every time
it starts to disable conflicts, when running multiple compilers at the same
time. This is done by creating a directory in the directory pointed at by the
environment variables %TMPDIR%, %TEMP% or %TMP%, in that order, until one of
them exists. If none of them exists, the current directory is assumed. Then
RHIDE puts the value of this directory into the environment variable
%TMPDIR%. After leaving RHIDE this directory will be removed, if it is empty.

2.4 Running under OS/2
======================

Because I have no access to OS/2, I cannot say anything about it. But some
people said that they run RHIDE under OS/2 successfully, but there must be
the exclusive mouse access to the DOS window disabled.

2.5 Running under Windows NT
============================

2.6 Running under Linux
=======================

Since RHIDE is now available also for Linux here some hints. In general you
will get the best results when you have installed RHIDE as a setuid root
program. I know, this might be a security problem but I have tried to make it
as secure as possible. After getting acces to the screen and the keyboard
RHIDE will switch back to your normal rights and does not use root rights any
more. It does not write any data or modify any file on disk with root rights
(except you are running as root of course).

The reason for this is the rudimentary support for fast access to the screen
and the totally hided acces to the keyboard in the Linux kernel.
Additionally when you want to use the dual monitor debugging feature of RHIDE
this is also needed, because RHIDE needs in that case access to the ports of
your monochrome video card.

Running RHIDE under X-Window is not full supported (but it is possible).
There are several reasons for this. The first is, that RHIDE uses in that
case only terminal functions for input and output. That means it depends
completetly on your terminfo database and these are (at least for me) in some
cases totally wrong. You can see this mostly that RHIDE does not handle
correct the keyboard. Other programs which use ncurses know this also and
have there own hardcaded patches but I do not want to do so.

To fix the keyboard conflicts whenrunning in a xterm, I distribute little
modified terminfo file `/usr/local/share/rhide/xterm-rhide' which you can
place in `/usr/lib/terminfo/x' or when you have no root access you can place
it also in `$HOME/.terminfo/x'.  And then to use this file simply set the
environment variable to this new terminal with
  export TERM=xterm-rhide
before running RHIDE in the xterm.

An other alternative is to run RHIDE in a rxvt terminal but there you have to
set also explicitely the TERM variable, because it is set mostly to
xterm-color.
  export TERM=rxvt

2.7 General use of RHIDE
========================

2.7.1 Creating a program
------------------------

For creating a program, RHIDE allows you to define multiple source files
which should be compiled and linked to your final program. This is done by
creating a project. In this project you insert your source files (and not all
the include files).

After a source file (which is inserted in your project) compiled at least
once, RHIDE knows about all dependencies of this file, so this file will be
compiled again only, if one of the include files have changed.

2.7.1.1 Creating a program without a project
............................................

Because of many requests of users I made RHIDE to work also without using a
project. This may be good, if you have a single file, but if your program
should be build from more than one file I suggest you to use a project.

If you have only one editor window opened, the name of the resulting program
is taken from the name of the source file by removing the suffix and on DJGPP
appending `.exe'.

If you have more than one files opened, I saw no other way for determining
the name of the produced program, than naming it `aout' (on DJGPP `aout.exe').

2.7.2 Creating a library
------------------------

You can also create libraries (a collection of object files, which can be
linked with other programs) with RHIDE. The way for doing this is very
simple. Because RHIDE knows about the meaning of file suffixes, you can
change the name of the main target (See Section 3.8.7) to have a suffix `.a'
and that's all. Now RHIDE will run `ar' instead of linking.

2.7.3 Saving/Loading the options
--------------------------------

RHIDE supports two different ways for saving the options which you have
customized.

The first one (which I prefer) is the use of the so called default project.
This is the project `rhide.gpr' and must be located in the same directory
where `rhide.exe' is. To create or modify this default project change to that
directory (normally %DJDIR%/bin) and type there

     rhide rhide

Now change any options you want and exit RHIDE. From now on these options are
used for any newly created project or when running RHIDE without a project.

The second way is to save your options to a project file (See Section 3.2.3
options) or to load them from any existing project file (See Section 3.9.8).

3. Description of the pull-down menus
*************************************

This chapter describes the pull-down menus and all their sub-menus.  The main
menu bar, the topmost line of the screen, is selected with the hotkey <F10>
or by clicking with the mouse at this line. You can walk through the menu
with the cursor keys and a menu entry is selected with <ENTER> or by clicking
with the mouse on it.

3.1 System menu
===============

This menu has its name only that one can speak about it. The symbol for this
menu is the leftmost symbol in the menu bar.  <Alt+SPACE> selects this menu.

3.1.1 About
-----------

This brings up a window with information about the author and the version of
RHIDE.

3.1.2 Bug report
----------------

This menu entry opens an editor with some important information which should
be part of a bug report and where you can describe the problem.

3.1.3 FSDB
----------

With this menu item you can call the FSDB debugger, which comes with DJGPP.
But remember, this runs the debugger as an external program and it is not
integrated in RHIDE.

3.1.4 GREP
----------

This is a very useful function. You can type the arguments for grep in the
input line, which will be shown, and after this the program grep is called.
The messages from grep are redirected to the message window (See Section 4.8).

3.1.5 GDB
---------

This is analog to the call of FSDB (See Section 3.1.3).

3.1.6 Refresh Desktop
---------------------

This function is sometimes useful, if you had run your program and it wrote
some things to the screen (for redirecting `stdout' and `stderr' from your
program to a window in RHIDE (See Preferences)).

3.1.7 Calculator
----------------

This brings up a dialog, where you can do some calculations. This dialog is
similar to the evaluate dialog (See Section 3.7.2), but it uses not the
feature of GDB, but it is a separate calculator.  For more information See
Documentation for the editor in "SET's editor", or point your Web browser to
http://editor.html

There can be used also some of the standard functions like `log', `sin' and
so on and it can convert also integer values between different bases (`hex',
`oct', `dec').

3.1.8 Puzzle
------------

This will open a small window, where you can play a little puzzle game. The
"stones" are moved with the cursor keys or by clicking with the mouse on it.

3.1.9 Calender
--------------

This will open a little calender. With the cursor keys <Up> and <Down> you
can switch to the next/previous month or click with the mouse on the small
symbols in the upper corners.

3.1.10 ASCII table
------------------

This will open a window with all the ASCII characters. Move around with the
cursor keys or press any key to select any wanted character.  In the bottom
line you will see the the character and the value of it (decimal and
hexadecimal). The decimal value can be used to create that character for
instance in the editor by holding the <Alt> key down and typing the value on
the numeric key pad.

3.2 File
========

In this menu you can find functions, which deal with files, like open, close,
save and so on.

3.2.1 Open
----------

Brings up the file-open dialog, where you can select a file to open (hotkey
<F3> ). This dialog contains an input line for the filename, a list of
filenames, an information window and the buttons for opening and canceling.

In the filename input line you can type directly the file, which you want to
open or you can type any mask to list only some files. The default mask is
`*.cc', but you can change this to anything and your last typed mask is
stored as the default mask for the next use. There is also a history of your
previous typed inputs available. This is selected when you hit the down key
or click at the small symbol at the end of the input line with your mouse.

The list of filenames shows all the files that correspond to the mask.  If
this list is selected you can choose a file with the cursor keys, or you can
type the first letters of the filename you want, and the bar is located at
the first file, which has these letters as the first characters. To open the
file simply press <ENTER> or double click with the mouse on it.

Below the list of filenames there is a small window with information about
the selected file (complete path, size, modification time).

To leave the dialog without opening a file press <ESC> .

3.2.2 New
---------

This is the menu entry for creating a new file to edit. This file gets the
title 'Untitled'. If you save or close it, you will be prompted for a new
name of this file by opening the file-open dialog.

3.2.3 Save
----------

Save the file in the current editor-window to disk. If the name of the
current file is 'Untitled' you will be prompted for a new name. <F2> is the
hotkey for this function.  The modification of the file on disk is set to the
time of the last modification of this file and not to the time when saving to
disk.

If the file was not modified, it is not saved!!

3.2.4 Save as
-------------

Save the file in the current editor-window to disk under a different name,
for which you will be prompted. For choosing the new name the file-open
dialog will be opened.

3.2.5 Save all
--------------

Save all the editor files to disk. If they are not modified, they will not be
saved.

3.2.6 DOS Shell
---------------

This executes a DOS-Shell. This is done by calling the program, which is set
in the environment variable COMSPEC. If this variable does not exist, the
program `c:/command.com' is executed.  To return to the IDE type `exit' at
the DOS-prompt. Before calling DOS, the program does a *Save all* (See
Section 3.2.3 all) automatically.

3.2.7 Exit
----------

Here you can quit the IDE. If there are any unsaved editor-files, you will be
prompted for saving them. (<Alt+X> is the hotkey.)

3.3 Edit
========

In this menu you can activate functions, which are related to the integrated
editor. Most of them have a hotkey.

3.3.1 Undo
----------

This undoes your last change in the current editor-window.  <Alt+Backspace>
is the hotkey for this function.

3.3.2 Redo
----------

This does the reverse to undo (See Section 3.3.1). That means, it is the undo
of the undo.

3.3.3 Cut
---------

This *moves* the selected text in the current editor-window to the clipboard.
(<Shift+Del> is the hotkey.)

3.3.4 Copy
----------

This *copys* the selected text in the current editor-window to the clipboard.
(<Ctrl+Ins> is the hotkey.)

3.3.5 Paste
-----------

This inserts the selected text in the clipboard in the current editor-window
at the current cursor-position. (<Shift+Ins> is the hotkey.)

3.3.6 Show Clipboard
--------------------

This brings up an editor-window with the contents of the clipboard. The
contents of the clipboard will be lost, if you exit the IDE.

3.3.7 Clear
-----------

This erases the selected text in the current editor-window.

3.3.8 Copy to Windows clipboard
-------------------------------

This is the same function as See Section 3.3.4 but it uses the Windows
clipboard and works only, when running under Windows.

3.3.9 Paste from Windows clipboard
----------------------------------

This is the same function as See Section 3.3.5 but it uses the Windows
clipboard and works only, when running under Windows.

3.3.10 Expand all tabs
----------------------

When selecting this menu entry, all real tabs (all characters with the code
`0x9') are expanded to as many spaces as defined as the tabsize (See
Preferences).

3.3.11 Compact text
-------------------

This function is the reverse to (See Section 3.3.10). That means, RHIDE tries
to make as many as possible spaces (count is taken from the defined tabsize)
to real tabs.

3.3.12 Macro
------------

Here is a submenu for handling macros. Currently there is only one recordable
macro available and it is NOT stored anywhere. That means it is lost when you
leave RHIDE and restart it. There is another way of using macros (See Section
4.13).

3.3.12.1 Record
...............

After selecting this function, all your keystrokes are recorded to reproduce
them later.

(<Shift+F10> is the hotkey.)

3.3.12.2 Stop
.............

This stops the recording of a macro.

(<Alt+F10> is the hotkey.)

3.3.12.3 Play
.............

This executes the recorded macro.

(<Ctrl+F10> is the hotkey.)

3.4 Search
==========

Menu for searching and replacing strings in the editor-window. These functions
have also hotkeys.

3.4.1 Find
----------

Find a string in the current editor-window. You can type the string for
searching in an input line and you can also select, if the search is case
sensitive or not and to search for whole words only or not.

(<Ctrl+Q+F> is the hotkey.)

3.4.2 Replace
-------------

Find and replace a string in the current editor-window. This works in the
same way like searching text, but additionally you can give a string, with
which the found text will be replaced.

(<Ctrl+Q+A> is the hotkey.)

3.4.3 Search again
------------------

This function repeats the last search or replace operation.

(<Ctrl+L> is the hotkey,)

3.4.4 Goto line
---------------

After prompting for a line number (with range checking), the cursor will be
located at this line.

(<Ctrl+J> is the hotkey.)

3.4.5 Jump to function
----------------------

With this feature you can easily jump to the source line of a function to
edit or see it. This is only a heuristic by parsing your source file and does
not take the information from the debugging symbols.

After selecting it you will get a dialog, from where you can select the
function to which you want to jump.

(<Alt+F2> is the hotkey.)

3.4.6 Next message
------------------

This selects the next message in the message window (See Section 4.8), but
only, if there is a next message available.

(<Alt+F8> is the hotkey.)

3.4.7 Previous message
----------------------

This selects the previous message in the message window (See Section 4.8),
but only, if there is a previous message available.

(<Alt+F7> is the hotkey.)

3.5 Run
=======

In this menu you find the functions for running your program.

3.5.1 Run
---------

If your project-target is an executable, this will be run after doing a Make
(See Section 3.6.2). <Ctrl+F9> is the hotkey. If the build was not
successful, the program will not be started. The debugging functions are only
available if `-g' was used for compiling.  (See Section 2.2)

3.5.2 Step over
---------------

This executes the code for exactly one source line. If there is a function
call at the current line this function is executed at once without stepping
through this function.

When using the <Shift>-key, RHIDE will NOT switch to the user screen when
executing the debuggee.

(hotkey <F8> or hotkey <Shift+F8> may be used.)

3.5.3 Trace into
----------------

This is the same as Step over (See Section 3.5.2), except when there is a
function call at the current line and for this function debugging information
is available, RHIDE steps into this function.

When using the <Shift>-key, RHIDE will NOT switch to the user screen when
executing the debuggee.

(hotkey <F7> or hotkey <Shift+F7> may be used.)

3.5.4 Go to cursor
------------------

This will execute your program until the execution comes to the line, where
the cursor is. If the program is stopped at any other place by a breakpoint
the program will stop there and not at the cursor position.

When using the <Shift>-key, RHIDE will NOT switch to the user screen when
executing the debuggee.

(hotkey <F4> or hotkey <Shift+F4> may be used.)

3.5.5 Program reset
-------------------

This 'kills' your debuggee at the current execution point without executing
any other code of your program

(<Ctrl+F2> is the hotkey.)

3.5.5.1 Main function
.....................

Here you can define the name of the `main' function of your program. This is
needed at least when debugging programs, (like written with GNU Pascal or GNU
Fortran), where the function of your main program is not `main'.

But you can use this also to debug your program at locations, which are
executed normally before `main' is called (for instance the global
constructors).

3.5.6 Arguments
---------------

Here you can type the arguments, which will be passed to your program when
you do a *run*. (See Section 3.5.1) and (See Section 2.2).

3.6 Compile menu
================

Here are the functions to translate your source files and for updating your
project.

3.6.1 Compile
-------------

Compile the file in the current editor-window or the selected entry in the
project-window if you are there. The IDE chooses automatically the correct
compiler, depending on the suffix of the file.  (See Section 2.1)

(<Alt+F9> is the hotkey.)

3.6.2 Make
----------

This makes your project up to date. It works like MAKE on commandline with a
makefile. <F9> is the hotkey. The dependencies are checked for each item of
the project. These dependencies are automatically generated, if you compile a
file within the IDE.

3.6.3 Link
----------

This function has two different results depending on the type of your
project. If your project is an executable (See Section 2.1), the linker is
started. But if it is a library, all the object files are taken to build a
library.

3.6.4 Build all
---------------

This builds the project completely new with compiling and linking all of the
project-items.

3.7 Debug
=========

This menu contains the functions for debugging your program. Most of them
have hotkeys and they are described in more detail later (See Section 3.7ging
with RHIDE).

3.7.1 Set/Reset Breakpoint
--------------------------

See Section 5.5.1

(<Ctrl+F8> is the hotkey.)

3.7.2 Evaluate/Modify
---------------------

See Section 5.3.2

(<Ctrl+F4> is the hotkey.)

3.7.3 Watch an expression
-------------------------

See Section 5.3.3

(<Ctrl+F7> is the hotkey.)

3.7.4 Breakpoints
-----------------

See Section 5.5.2

3.7.5 Disassembler window
-------------------------

This opens a window, where you can see assembler instructions.  When you are
running the debugger, you will see the instructions at the current execution
point of your program.

You can step See Section 3.5.2 or trace See Section 3.5.3 here in the same way
like in an editor window and you can also debug code, which has no debugging
information.

Additionally you can scroll here also forwards or backwards but scrolling
backwards is very hard to implememnt and so you will get when scrolling
backwards most of the time wrong output. Sorry for this, but until I find
more time to implement this better you have to live with it.

3.7.6 Call stack
----------------

This shows a window with a list of functions, from which the current
execution point in the debugged program is called. If you hit <Enter> on a
function which has line number debugging information, you will go to the
source line which is shown in the window.

(<Ctrl+F3> is the hotkey.)

3.7.7 List of Functions
-----------------------

This asks first for a regular expression to list only those functions of your
program, which match that expression. The syntax for such a regular
expression is a little bit different from the wildcards you are probably
knowing from MS-DOS.

If you want to get a list of all functions you should enter either nothing
(the default), or ".*", or "?*" (both without the double quotes).  The
expression "*" does NOT mean all function. In fact, your entry will be
interpreted as a regular expression.

After you have typed the expression and pressed <Enter>, you will get a list
of functions that match the regular expression and for which debugging
information is available.

This list is sorted by the name of the function and has three parts:

NAME | RETURN VALUE | FILE

You can walk through the list with the cursor keys or the mouse. If you hit
<Enter> or double click a function, you will go the the source code of that
function.

3.8 Project
===========

Here you can add or remove items to or from your project

3.8.1 Open project
------------------

Here is the point to open a project. After selecting this menu item, the file
open dialog is opened to select a project. You can type the name of the
project or select one from the list.

If you open a project in another directory than the current, RHIDE will
change the current directory to this directory and then the project will be
opened.

If you type here a name of a project which does not exist, a new one is
created.

If no project was opened and you create a new project, all open desktop files
remain open, but they are not added to the project.  If a project was opened,
it will be automatically closed before the new project is opened.

3.8.2 Close project
-------------------

This closes the currently opened project and closes all files, which are on
the desktop.

3.8.3 Add item
--------------

A dialog will be opened, from where you can choose your file to add to your
project. If you are in the project window (See Section 3.10.9 window) you can
use the <Ins> key to activate this function within the project window.

Currently it is impossible to use relative or absolute paths as part of a
project item. If you have your files in several directories, you have to
setup either the search path for source files or you have to create for each
directory a library that can be included in your project.

3.8.4 Delete item
-----------------

This will remove the selected item in the project-window from your project.
If you are in the project window (See Section 3.10.9 window) you can use the
<Del> key to activate this function.

3.8.5 Local options
-------------------

Here you can give the selected project-item options for compiling, which will
be in effect only for this item. If you are in the project window (See
Section 3.10.9 window) you can use <Ctrl+O> to activate this function.  The
options you give here are passed to GCC only, when compiling this file.  For
more details see (See Section 3.8.5 for a project item).

3.8.6 Includes
--------------

This shows the dependencies for the selected item in the project window. You
can use the hotkey <Ctrl+I> in the project window.  (See Section 3.10.9
window)

3.8.7 Main targetname
---------------------

Here you can change the name of your main target. The main target is either
an executable file or a library. RHIDE selects the type of the main target
from the suffix of this name. If it has no suffix or the suffix `.exe', an
executable will be built. If it has the suffix `.a', a library will be
created.

Remember when you give it no suffix, both, the COFF image and the `.exe' file
will created. If it has the `.exe' suffix, only the `.exe' file is created.

3.8.8 Primary file
------------------

Here you can give the primary source file, when you want to use the
'automake' feature of GPC. If you type a source name here, RHIDE assumes that
your program is written in Pascal and does NOT check any dependencies of the
project, because this is done automatically by GPC with the `--automake'
option.

If you don't want to use the 'automake' feature of GPC, even when building a
Pascal program, give here an empty name, which is the default.

3.8.9 Clear dependencies
------------------------

This function removes all internal stored dependencies. The files are not
removed. This is useful when you want to create a makefile (See Section
3.8.11) and you do not want to include all the absolute filenames for the
dependencies (mostly the include files).

This function is a relict from earlier versions of RHIDE, but I have not
disabled it.

3.8.10 Delete rebuildable files
-------------------------------

This function includes the function of clearing the dependencies (See Section
3.3.7 dependencies) and removes in addition to it all the files, which can be
rebuild within RHIDE.

3.8.11 Write Makefile
---------------------

Here you can create a makefile that contains all the rules to build the
project from the command line without starting RHIDE. For this you need the
GNU make, because the generated makefile uses the features of GNU make very
extensively.

If you have used environment variables in your search paths (See Section
3.9.1), these are not expanded in the generated makefile.  But all variables
you used will be defined at the beginning of the makefile with their current
value.

3.9 Options
===========

This menu contains many submenus for anything you can customize.

3.9.1 Directories
-----------------

Here you can define all of the paths, where RHIDE and the compilers finds the
needed files and where to store some files.

All the paths you can define in the several entries have the form of a
semicolon separated list of directories, just like your environment variable
%PATH%. You can use forward slashes and back slashes, but they are all
converted to forward slashes by RHIDE. You can also use environment variables
as part of your paths. The syntax of such a variable is that of a GNU
makefile. If you want to use the variable %DJDIR%, you must type $(DJDIR).

3.9.1.1 Include directories
...........................

This is the list of directories, where GCC looks for include files and RHIDE
searches in this directory (after looking in the current directory) for
header files.

3.9.1.2 Library directories
...........................

This is the list of directories, where GCC looks for libraries when linking.
RHIDE searches in this directories (after looking in the current directory)
for libraries, if you have included them directly as a project item.

3.9.1.3 Object directories
..........................

This is the list of directories where RHIDE looks for object files.  If you
type here only one directory this has also the effect that the object files,
which are compiled, are stored in this directory.

3.9.1.4 Sources directories
...........................

This is the list of directories, where RHIDE looks for the source files
(after looking in the current directory).

3.9.1.5 Standard headers
........................

Define here a space separated list of directories where your standard headers
are. Header files found in these directories are not added to the list of
dependencies which is automatically generated when compiling a C/C++ source
file.

3.9.2 C/C++-Compiler
--------------------

In this submenu you can change most flags, which have to do when compiling C
or C++ files or better for the options of all the currently supported
compilers.

3.9.2.1 Warnings
................

This opens a dialog where you can enable or disable most of the flags for
generating or suppressing warnings when you compile a C or C++ file.  (See
Section 3.9.2.8).

For a detailed description of the available flags See Section 'Warning
Options' in documentation for 'gcc'.

3.9.2.2 Optimizations
.....................

This opens a dialog where you can customize how the compiler optimizes your
code.  (See Section 3.9.2.8).

For a detailed description of the available flags See Section 'Optimize
Options' in documentation for 'gcc'.

3.9.2.3 Debugging
.................

This opens a dialog where you can customize the amount of debugging
information the compiler should include in object files.  (See Section
3.9.2.8).

For a detailed description of the available flags See Section 'Section
3.7ging Options' in documentation for 'gcc'.

3.9.2.4 C options
.................

This opens a dialog where you can select flags that are only passed to GCC
when compiling C files.  (See Section 3.9.2.8).

For a detailed description of the available flags See Section 'C Dialect
Options' in documentation for 'gcc'.

3.9.2.5 CXX options
...................

This opens a dialog where you can select flags which are only passed to GCC
when compiling C++ files.  (See Section 3.9.2.8).

For a detailed description of the available flags See Section 'C++ Dialect
Options' in documentation for 'gcc'.

3.9.2.6 Pascal options
......................

This opens a dialog where you can select flags which are only passed to GPC
when compiling Pascal files.  (See Section 3.9.2.8).

For a detailed description of the available flags See Section 'Pascal Dialect
Options' in documentation for 'gpc'.

3.9.2.7 Fortran options
.......................

This opens a dialog where you can select flags which are only passed to g77
when compiling Fortran files.  (See Section 3.9.2.8),

For a detailed description of the available flags See Section 'Fortran
Dialect Options' in documentation for 'g77'.

3.9.2.8 How to toggle these flags
.................................

The options in the dialogs for Warnings, Debugging, C-flags and CXX-Flags are
selected with the cursor-keys or the mouse and are activated or deactivated
by pressing <SPACE> or by double-clicking with the mouse at the first field
of the option. If an option can take an additional value or string, an
inputbox will be opened, and you can type them there. If the additional value
is optional, you can leave this input-box by pressing <ESC> or activating the
*Cancel* button and no value, or the previous one will be appended to this
option.

3.9.3 Libraries
---------------

Here you can tell the linker which libraries will be linked in your program.
At this time the number of additional libraries is limited to 16. If you need
more, you have to type them manually (See Section 3.6.3er options).

In the input-fields of the dialog you only have to type the part of your
library name after `lib' and before `.a'. Example: If your library is
`libtv.a' put only `tv' there. You can switch between the input lines for the
libraries using <Tab> or <Down Arrow> (next field) or <Shift+Tab> or <Up
Arrow> (previous field). If you have typed your libraries you can activate or
disable them by switching the checkbox before the name on or off. This is
done by pressing <Alt> and the corresponding digit or letter of the checkbox
at the same time or by clicking with the mouse.

Normally RHIDE checks the types of your source-files and automatically adds
some standard libraries, corresponding to these source-files.  These are for
C++ files the library `libiostream.a' and for Objective C files the
`libobjc.a' library.  If you want to disable this, deactivate the *Use
standard libraries* checkbox. This adds also the commandline option -NOSTDLIB
to GCC, that means, you must give the linker explicitly all of the standard
libraries, which you need. This includes the `libgcc.a' and `libc.a'
libraries.

3.9.4 Linker options
--------------------

Here you can enter a space separated list of options that will be passed to
GCC when linking your program.  (See Section 2.2)

(See Section 2.2).

3.9.5 Compiler options
----------------------

Here you can enter a space separated list of additional options that will be
passed to GCC every time it is called.  (See Section 2.2)

(See Section 2.2).

3.9.6 Environment
-----------------

3.9.6.1 Colors
..............

Here you can customize all of the colors of the IDE.

3.9.6.2 Editor options
......................

autoindent
..........

When this is enabled, the editor automatically indents the next line by
referring to the previous line if you press enter.

For more information See Documentation for the editor in "SET's editor", or
point your Web browser to http://editor.html

(See Section 3.3or options)

Use tabs
........

When this is enabled, the character `\t' is inserted into the text if you
press the <Tab>-key. Otherwise the number of spaces (defined by tabsize) is
inserted.

For more information see See Documentation for the editor in "SET's editor",
or point your Web browser to http://editor.html

(See Section 3.3or options)

Persistent blocks
.................

Normally, RHIDE uses persistent blocks. This means the selected area will not
get unselected if you press a key. If you like the behavior of earlier
versions of RHIDE, disable this option.

For more information see See Documentation for the editor in "SET's editor",
or point your Web browser to http://editor.html

(See Section 3.3or options)

Intelligent C indenting
.......................

This option enables the so called 'C intelligent indenting', which is an
heuristic for indenting after special key words like `if' or `while' more
than the normal autoindenting. This works only if AUTOINDENT is enabled.

For more information see See Documentation for the editor in "SET's editor",
or point your Web browser to http://editor.html

(See Section 3.3or options)

Column cursor
.............

This is a special feature of the builtin editor. If you enable this option
you will see a vertical special color highlighted column across the whole
editor window at the cursor column.

For more information see See Documentation for the editor in "SET's editor",
or point your Web browser to http://editor.html

(See Section 3.3or options)

Row cursor
..........

This is a special feature of the builtin editor. If you enable this option
you will see a horizontal special color highlighted row across the whole
editor window at the cursor row.

For more information see See Documentation for the editor in "SET's editor",
or point your Web browser to http://editor.html

(See Section 3.3or options)

Match pair highlight
....................

If this option is enabled, you will see at any time you type a bracket, brace
or parenthesis the matching highlighted or a message, that there was no
matching found.

For more information see See Documentation for the editor in "SET's editor",
or point your Web browser to http://editor.html

(See Section 3.3or options)

Do not move the cursor on paste
...............................

Enable this option, when you want to leave the cursor at it's current
position when you paste some text.

(See Section 3.3or options)

Transparent Blocks
..................

When this option is enabled, the syntax highlight is still shown in selected
blocks.

(See Section 3.3or options)

Optimal fill
............

When enabling this option the editor fills the gaps in your text with an
optimal value of spaces and tabs.

(See Section 3.3or options)

Tabsize
.......

Additionally you can select here the tabbing size for the editor. This value
is used as the global setting for all editor windows which will be opened
after setting this value. The currently opened windows will use also this
setting.

(See Section 3.3or options)

3.9.6.3 Preferences
...................

Here you can customize some basic options for the work of the IDE. A dialog
will be opened where you can turn on or off the following options:

all dependencies in makefile
............................

When this is enabled, all internally stored dependencies for a project item
are written to the makefile.  (See Section 3.8.11). You should disable this
option, if you want to give another user the makefile of your project, and
(s)he has a different directory structure.

(See Preferences)

create backup files
...................

Create backup files when saving. When it is enabled, RHIDE creates a backup
of the file to save under the same name as the editing file, but the suffix
is replaced with `.bak'

(See Preferences)

syntax highlighting
...................

Turn the Syntax highlight on or off. RHIDE automatically checks the suffix of
the editing file to determine the correct syntax highlighting.  Currently
this is supported only for C, C++, and Pascal source files.  All other files
are not specially highlighted.

(See Preferences)

Use dual display
................

Here is an very powerful option. If you have installed on your computer a
secondary display (monochrome monitor) in addition to your VGA monitor, RHIDE
can (when this option is enabled) switch to the second monitor for it's
output and you can see your program on the normal monitor.

If this option is enabled and you have not a secondary monitor installed,
RHIDE will detect this and does not switch to it.

(See Preferences)

redirect stderr
...............

Turn this on, if you want to redirect the output to stderr of your program to
a window in the IDE. This is also needed, if you want to use the builtin
analyzing of a call frame traceback, when your program crashes.

(See Preferences)

redirect stdout
...............

Turn this option on, if you want to redirect the output to stdout from your
program to a window in the IDE.

(See Preferences)

show process information
........................

Turn this option on if you want to see which files are checked, when you do a
make (See Section 3.6.2), and to see the commandlines how the compilers are
started by RHIDE.

(See Preferences)

show free memory
................

Turn this option on to show in the upper right corner of the screen a readout
of the free memory of your system.  This shows both, the virtual and the
physical free memory.

(See Preferences)

No file caching
...............

If this option is enabled, RHIDE does not use the internal caching of
information about searching files and modification times. Use this only if
you have problems with the automatic checking of dependencies, because this
slows down RHIDE.

(See Preferences)

16 background colors
....................

On EGA/VGA video cards it is possible to use 16 background colors instead of
normal 8. This is done by telling the video card how to interpret the highest
bit of the color attribute. If you enable this, you can use up to 16
background colors, otherwise there are only 8 colors for the background
available. To get blinking foreground colors, you must use a little trick.
Enable at first this option here. Then change the color attribute to
highlight background color you want and then reset the '16 background colors'
option.

(See Preferences)

Show GDB commands
.................

When this option is enabled you can see in the GDB output window which
commands are sent to the builtin GDB from RHIDE.

(See Preferences)

Use no shadows
..............

When this option is enabled RHIDE uses no shadows at all for the windows and
dialogs and so on.

(See Preferences)

Save text palette
.................

When you debug a program, which modifies the palette when in text mode, you
should enable this option.

Save project only when closing
..............................

Enable this option only, when you get a system crash after starting your
program and because of the use of disk cache the project, which RHIDE
automatically saves before your program is run, is corrupted.

Screen mode
...........

Here you can select the video mode. If you want to use a video mode other
than the ones shown, you have to select the USER MODE mode and type the value
of this mode (see in the reference of your video card) as a decimal or
hexadecimal (preceeded by `0x') number. But you can use only textmodes (modes
with starting video ram address at `0xB800:0000'. For the numbers of the
videomodes refer to the documentation of your video card.  If you type an
invalid videomode (RHIDE checks it), the 80x25-Mode will automatically
selected.

I have tested all available text modes with my et4000-card, and they work.
For some modes, (mostly every high resolution text mode) the mouse cursor is
shown by my own routine.  That means that you can use the mouse also in the
high resolution text modes.

(See Preferences)

3.9.6.4 Mouse options
.....................

Here you can customize a little bit the speed of the double click interval
and you can also tell RHIDE to reverse the mouse buttons.

3.9.6.5 Reserved words
......................

This opens a dialog, where you can modify the list of reserved words the
editor knows. If you choose the *Default* button in this dialog, the default
reserved words are generated and any previous words are lost.

3.9.6.6 Pascal reserved words
.............................

This opens a dialog, where you can modify the list of reserved words for
Pascal the editor knows. If you choose the *Default* button in this dialog,
the default reserved words are generated and any previous words are lost.

3.9.6.7 C-Flags
...............

Here you can modify the list of C options, which you can turn on or off. (See
Section 3.9.2.4)

(See How to change the list of flags)

3.9.6.8 CXX-Flags
.................

Here you can modify the list of CXX options, which you can turn on or off.
(See Section 3.9.2.5)

(See How to change the list of flags)

3.9.6.9 Pascal-Flags
....................

Here you can modify the list of Pascal options, which you can turn on or off.
(See Section 3.9.2.6)

(See How to change the list of flags)

3.9.6.10 Fortran-Flags
......................

Here you can modify the list of Fortran options, which you can turn on or
off. (See Section 3.9.2.7)

(See How to change the list of flags)

3.9.6.11 Warning-Flags
......................

Here you can modify the list of Warning-Flags, which you can turn on or off.
(See Section 3.9.2.1)

(See How to change the list of flags)

3.9.6.12 Debugging-Flags
........................

Here you can modify the list of Debugging-Flags, which you can turn on or off.
(See Section 3.7ging)

(See How to change the list of flags)

3.9.6.13 Optimization-Flags
...........................

Here you can modify the list of Optimization-Flags, which you can turn on or
off.  (See Section 3.9.2.2)

(See How to change the list of flags)

3.9.6.14 User words
...................

Here you can define your own list of words, which can be specially
highlighted, when syntax highlighting is enabled. (See Preferences)

How to change the list of flags
...............................

The syntax of the strings, which you can modify or add with the last
menu-entries is any string followed by an optional modifier with the
following meaning:

`%d'
     if you activate this option, you *must* enter an integer there

`%d?'
     if you activate this option, you *can* enter an integer there

`%c'
     if you activate this option, you *must* enter a character there

`%c?'
     if you activate this option, you *can* enter a character there

`%s'
     if you activate this option, you *must* enter a string there

`%s?'
     if you activate this option, you *can* enter a string there

`%s(STRING)'
     if you activate this option, you *must* enter a string, which contains
     only characters defined by the string STRING, there

`%s?(STRING)'
     if you activate this option, you *can* enter a string, which contains
     only characters defined by the string STRING, there

As an example: the string for the `-O' option is defined as `-O%d?' and the
`-d' option (See Section 3.7ging) is defined as
 `-d%s(MNDyrxjsLtfcSlgRJdkamp)'
which means, the string after `-d' must be a combination of the characters in
 `MNDyrxjsLtfcSlgRJdkamp'
If you leave the dialogs for modifying the flag lists with the *OK* button or
if you activate the *Default* button, all flags are disabled

3.9.7 Save options
------------------

Here you can save all the options you currently customized to a file.  RHIDE
restricts this to saving them only to a file with the `.gpr' suffix (and
`.gdt' for the desktop file).

3.9.8 Load options
------------------

Here you can load the options from any existing project file.

3.10 Windows
============

In this menu you get the functions for arranging, resizing and switching
between the windows on the desktop:

3.10.1 Size/move
----------------

With this function you can resize and/or move the current window. After
selecting this, the frame of the current window will be drawn light-green and
you can move it with the cursor-keys. To resize it, press <Shift+>
cursor-keys. To exit the moving/resizing function, press <ESC> or <ENTER>.
Alternatively you can use the mouse.  For moving, click on the top of the
window and hold the left button down. Now you can move the window by moving
the mouse. To resize it, click on lower right corner of the window, hold the
button down and resize the window by moving the mouse. (This function has the
hotkey <Ctrl+F5> )

3.10.2 Zoom
-----------

This brings up the window to maximal size or to previous size.  (hotkey <F5>
or click with the mouse at the symbol on the right upper corner of the window)

3.10.3 Tile
-----------

This arranges all the editor-windows on the desktop, to see them all
simultaneously.

3.10.4 Cascade
--------------

This arranges all the editor-windows on the desktop, to see the contents of
the current editor-window and the top-frame of all the others.

3.10.5 Next
-----------

Hotkey <F6> switches to the next window on the desktop.

3.10.6 Previous
---------------

Hotkey <Shift+F6> switches to the previous window on the desktop.

3.10.7 Close
------------

This closes the current window. If it is an editor-window and its contents
were modified, you will be prompted to save it. Hotkey <Alt+F3> or click with
the mouse on the upper-left symbol of the frame.

3.10.8 List
-----------

Hotkey <Alt+0> brings up a list of all windows that are currently on the
desktop. You can select one of them and press <ENTER> to switch to it. With
<Del> you can close the selected window.

3.10.9 Project
--------------

With this function you can select the project window (See Section 3.10.9
window). If it was closed, it will be opened.

3.10.10 UserScreen
------------------

Hotkey <Alt+F5> shows the contents of the DOS-Screen.  To leave this
function, do any event. That means, press any key, or click with the mouse.

3.11 Help
=========

In this menu you have access to many predefined help entries in the big help
system.

3.11.1 Help
-----------

This opens the INFO viewer. Many thanks at this point to Salvador Eduardo
Tropea (SET). He wrote the very good INFO viewer for use with RHIDE. This was
also the most important reason for me to write the documentation in Texinfo,
because you have now an online help available with the produced INFO file
`rhide.info'.

Pressing <F1> invokes the help system from everywhere.  For help on using the
INFO viewer, press <F1> within the help window.  But the above things work
only if you have correctly installed the INFO files that come with RHIDE.

If you have installed the binary archive of RHIDE as described in the
`readme.bin', the INFO files are in `%DJDIR%/info'. If you have not modified
your `djgpp.env' file, this directory is searched for the INFO files.

But you can put the INFO files in any directory you want, if you add this
directory to the %INFOPATH% variable in your `djgpp.env' file in the section
for `info'.

3.11.2 RHIDE Help index
-----------------------

This brings up the help window with the main index for getting help for RHIDE.

3.11.3 Syntax help submenu
--------------------------

In this submenu you can set the files to be searched for getting syntax help
and you can also customize the options, how this is done.

3.11.3.1 Syntax help
....................

If you are in an editor window, and you press <Ctrl+F1> , you get help about
the function under or before the cursor.  But only if this function is
documented in the files you have given to be searched for. (See Section 3.2s
to search) If there was no help found you will be informed.  This feature can
be used also by clicking with the right mouse button on the word.

3.11.3.2 Files to search
........................

Give here a space separated list of files (if you give no suffix, the
standard suffixes are tried) which should be scanned for getting help for a
word.

3.11.3.3 Options for searching
..............................

Here you can give some options, how the syntax help should work. The
following search methods are selectable and other options. For all the search
methods it is possible to get more than one matching topic. If that is true,
you will find a list, from which you can select the wanted topic.

Exact
.....

When this is selected, you will get syntax help only, if in the selected
files a topic with that exact name was found.

Substring
.........

When this is selected, you will get syntax help, when the word is a substring
of any of the nodes in the files to be searched for syntax help.

Fuzzy
.....

This method uses a "Fuzzy search" for getting syntax help. That means it
looks also for nodes, which are similar to the word for which you want to get
syntax help.

Search options
..............

These are several options for the textual search:
`Case sensitive'
     When this is selected, the textual search is case sensitive.

Here you can set the bound for the fuzzy search. The range is from 1 to 1000
where 1 means that mostly every string matches any other string and 1000
means the exact match.

3.11.4 Index for syntax help
----------------------------

Here you can get a list of all available topics for the syntax help, from
where you can choose one (<Enter>, <Space> or double click).

3.11.5 libc reference
---------------------

This is a separate menu entry to open the libc reference, because this is
used very often when writing C programs.

3.11.6 Help about help
----------------------

This brings up a help-window for instructions and available keystrokes when
using the integrated INFO viewer.  (See  in "infview", or point your Web
browser to http://INFO Viewer)

4. Detailed description of some parts of RHIDE
**********************************************

4.1 Selecting a window
======================

To select a window you can do the following. If the window has a number, this
is right on the top-frame, you can select this window by pressing <Alt> and
this number (but only if the number is a single digit).  Or you click
anywhere in the window or on the frame of the window with your mouse.

4.2 How the editor works
========================

This section should describe the work of the editor. But because the editor
is now so complex and, not my own work, there is now separate documentation,
See Documentation for the editor in "SET's editor", or point your Web browser
to http://editor.html for a detailed and better doc. But you can read also
more from my doc, which describes the most common (for me) usage of the
editor.

Here I describe most of the editor commands. If there is a key command like
`Ctrl+Q+Y', press <Ctrl> and <Q> simultaneously and after this press <Y>.

I strongly recommend not to use the technique by holding down the <Ctrl> key
when pressing the second key in such key combinations, because for instance
when you press `Ctrl+K' and then `Ctrl+C' you will be prompted if you want to
interrupt RHIDE (because you pressed the interrupt key). But if you really
want to use this methode, you should use the `-C' commandline switch when
starting RHIDE to disable the handling of `SIGINIT'.

4.2.1 Erasing commands
----------------------

   * <Ctrl+G> or <Del> erases the character under the cursor or the selected
     text.

   * <Ctrl+H> or <Backspace> erases the character before the cursor or the
     selected text.

   * <Ctrl+Y> erases the current line.

   * <Ctrl+Q+Y> erases from the cursor to the end of the line.

   * <Ctrl+Q+H> erases from the cursor to the beginning of the line.

   * <Ctrl+T> erases from the cursor to the beginning of the next word on
     this line.

   * <Ctrl+Backspace> erases from the cursor to the beginning of the previous
     word.

4.2.2 Cursor moving commands
----------------------------

   * <Ctrl+S> or <Arrow left> moves the cursor one character left.

   * <Ctrl+D> or <Arrow right> moves the cursor one character right.

   * <Ctrl+E> or <Arrow up> moves the cursor one line up.

   * <Ctrl+X> or <Arrow down> moves the cursor one line down.

   * <Ctrl+A> moves the cursor one word left.

   * <Ctrl+F> moves the cursor one word right.

   * <Ctrl+C> or <Page down> moves the cursor one page down.

   * <Ctrl+R> or <Page up> moves the cursor one page up.

   * <Ctrl+Q+D> or <End> moves the cursor to the end of the line.

   * <Ctrl+Q+S> or <Home> moves the cursor to the beginning of the line.

   * <Ctrl+Q+R> or <Ctrl+PgUp> or `Ctrl+Home' moves the cursor to the
     beginning of the file.

   * <Ctrl+Q+C> or <Ctrl+PgDown> or `Ctrl+End' moves the cursor to the end of
     the file.

4.2.3 Text selecting and searching commands
-------------------------------------------

   * <Shift> cursor keys select the text as the cursor moves.

   * <Ctrl+Ins> or <Ctrl+K+K> copy the selected text to the clipboard.

   * <Shift+Del> or <Ctrl+K+Y> move the selected text to the clipboard.

   * <Shift+Ins> or <Ctrl+K+C> copy the selected text from the clipboard to
     the current cursor position.

   * <Ctrl+Del> delete the selected text.

   * <Ctrl+Q+A> open the replace dialog.

   * <Ctrl+Q+F> open the find dialog.

   * <Ctrl+L> repeat the last replace or find operation.

   * <Ctrl+K+H> unselect all.

4.2.4 Block commands
--------------------

   * <Ctrl+K+B> sets the start of the selected block.

   * <Ctrl+K+K> sets the end of the selected block.

   * <Ctrl+K+I> indents the selected block by inserting a space at the
     beginning of each line inside the block.

   * <Ctrl+K+U> unindents the selected block by erasing one character from
     the beginning of each line inside the block, which starts with a tab or
     space.

   * <Ctrl+K+M> converts all alpha characters inside the selected block to
     upper case.

   * <Ctrl+K+O> converts all alpha characters inside the selected block to
     lower case.

   * <Ctrl+K+V> moves the selected block to the current cursor position.

   * <Ctrl+K+Tab> indents the selected block by using the last non selected
     line as reference for indenting.

   * <Ctrl+K+Shift+Tab> unindents the selected block by using the last
     non-selected line as reference for unindenting.

   * <Ctrl+K+R> inserts the contents of a file at the current cursor position.

   * <Ctrl+K+W> writes the selected block to a file.

4.2.5 Other commands
--------------------

   * <Ctrl+V> Toggle insert-/overwrite-mode.

   * <Ctrl+O> Toggle auto-indent-mode on/off.

   * <Ctrl+J> Goto line ... (Will be prompted for.)

   * <Ctrl+K+?> ?, a digit (<0> - <9>). Set a marker in the text (up to ten
     different markers).

   * <Ctrl+Q+?> ?, a digit (<0> - <9>). Jump to a marker, which you have
     previously set.

   * <Shift+Space> Executes a macro, which can be defined externally by
     analyzing the last two characters before the cursor.  (See Section 4.13)

If you have set some markers, they will be stored, so you can use them later
when restarting RHIDE.

4.3 Some hints and problems
===========================

To compile only a single file, you don't need to include it in a project.
You only have to open it and do a compile. If a file is in your project, you
can compile it, if you are in its editor-window or if you are in the
project-window and this file is selected.

Warnings and errors from compiling a file are listed in the message-window.
If there are warnings or errors, you can jump to the corresponding source by
hitting <ENTER> on this message. If this file wasn't already opened, it will
be opened.

4.3.1 Problems with automatic dependencies
------------------------------------------

Most checking of the dependencies works correctly, but there are some few
situations, where this checking gets confused. The first results in the fact
that I implemented a cache function for getting the modification time of
files, that means, most files are 'stat'ed only once, after starting RHIDE.
But if someone modifies one of the files, which are in the cache, (this can
be another program, when you run RHIDE in a multitasking environment, such as
Windows) or if you run your project and it modifies some of these files, the
internal cache is after this not up to date.

Here is another situation. Your source files are not in the current
directory. You have opened a source file for editing and successfully built
your project. Now you leave RHIDE, because you want to debug your program
with `FSDB', you copy the source file (in this case it is the file, which you
have opened in the IDE) to the current directory. Now you debug it and there
are some errors. You restart RHIDE to make the changes in the file. The
previously opened file will be opened automatically and you edit it. If you
do now a *Make*, RHIDE tells you, that your project is up to date, because it
searches for source files at first in the current directory, and there is the
unmodified file.

In this chapter I will give you for some special parts a more detailed
description of what they do.

4.4 Project window
==================

The project window shows you every file, which you have included in your
project. Most time you work with RHIDE this window should be visible, but you
can also close it (See Section 3.10.7).

4.4.1 Items of your project
---------------------------

The items in the project window, and therefore also in your project, are
sorted in alphabetical order. This has the effect of faster finding an item
and you can also move the selecting bar to a specified item by typing the
name of this item.

Normally, the alphabetic order of the project items causes no problems because
the linker searches at first *every* object file for unresolved symbols
before any library. The statement, the the GNU linker is a one pass linker
makes sense only for libraries, because they are checked only once for
unresolved references. That means, if you include libraries in your project
you must know about the order, where this library is put on the command line
when linking your program.

If you have problems with that order, or if you really want to have one
object file (or library) before some others, you must rename them, to get the
right position from the name.

4.4.2 Open a project item
-------------------------

To open an editor window with the selected item press either <ENTER> or
<SPACE>. If there was already a window with this file opened on the desktop,
this window will be selected.  This works only if the selected item has a
known suffix (See Section 2.1). If the selected item is a project file, that
project will be opened with the side effect that if you close this project,
the previous one will be reopened.

4.4.3 Dependencies of project item
----------------------------------

If you have compiled a file already in RHIDE, you bring up a list with all
dependencies of that file. In this list the files are show by their basename
followed by the directory and they are also sorted in alphabetical order.
From here you can also open an editor window with the selected dependency by
pressing <SPACE> or <ENTER> on that item.

4.4.4 Local options for a project item
--------------------------------------

You can change many options for a project item, which are in effect only for
this file. To do this, hit <Ctrl+O> on the selected item and a dialog is
shown, where you can change the options.

At this time you can change the following options.

Local commandline options
.........................

Here you can give some additional defines or any other commandline options,
when compiling this item.

exclude from link
.................

This is a switch to tell RHIDE, that this file should not be linked with your
program, but it is compiled and it is checked to determine if your program is
up to date.

rebuild seldom
..............

When you select this option the item is compiled only if it does not already
exist. For most project items this is not usefull but if you have included in
your project other projects which create a library this might be usefull,
especially if the library has many source files and you know, that they
change very seldom.

Name of the output file
.......................

Here you can specify another name as the compiled file. Put here only the
basename of the file (without any directory)

Compiler type
.............

From that list you can select exactly one type of the compiler, which is used
to create your output file. Possible values are:

`Auto'
     This is the default and should be used in most cases. When this type is
     selected, RHIDE selects the correct compiler depending on the suffixes
     of your source and output file.

`User'
     If you have any special compiler, which is not known to RHIDE, to create
     your output file, you must select this and give RHIDE also the calling
     syntax of that compiler (see below)

`None'
     If you don't want to compile this item select this.

`GNU C compiler'
     Tell RHIDE to compile this file like a normal GNU C source file.

`GNU C++ compiler'
     Tell RHIDE to compile this file like a normal GNU C++ source file.

`GNU assembler'
     Tell RHIDE to compile this file like a normal GNU assembler file.

`GNU Pascal compiler'
     Tell RHIDE to compile this file like a normal GNU Pascal file.

User defined compiler
.....................

If you have selected the User compiler type, you have to put in the next
input line the specs on how to call the compiler. These specs can use any
variables that are known to RHIDE (See Section 4.6) together with normal
text. As an example I show here, how the builtin C compiler is defined (the
backslashes at the end of the lines are used only here to show, that the line
is continued, they are NOT part of the specs):


$(RHIDE_GCC) $(INCLUDE_DIRS) $(C_DEBUG_FLAGS) $(C_OPT_FLAGS) \
$(C_WARN_FLAGS) $(C_C_LANG_FLAGS) $(C_EXTRA_FLAGS) $(LOCAL_OPT) \
-c $(SOURCE_NAME) -o $(OUTFILE)

Error checking
..............

Here you can select how errors or warnings that are produced by the compiler,
are checked. Possible values are:

`Auto'
     Let RHIDE select the correct way for checking the errors

`User'
     Use your own external program to check the output of the compiler to
     `stderr'

`None'
     Do not check any errors, assume that the compiler does it's job every
     time successfully.

`builtin C'
     Check the errors like when compiling a C file

`builtin assembler'
     Check the errors like when compiling an assembler file

`builtin linker'
     Check the errors like when linking

`return value'
     Determine only if the compiling was successful or not by checking the
     return value of the compiler (zero for success)

Error program
.............

If you have selected above the User error checking, type here the program,
which should check for errors and/or warnings.  What the external error
checking program should do:

   - The program must take a filename as argument, which contain the output
     to stderr from the compiler (Error and warning messages)

   - The program has to write to stdout the Warnings, Errors or messages in a
     special format.

    `Errors'
          A line that starts with the string "!Error" (without the double
          quotes) optionally followed by "!File" and a filename in single
          quotes and "!Line" followed by a space and a line number and
          "!Column" followed by a space and a coloumn number.

          If "!Line" and/or "!Column" are not used they dafault to 0.  The
          next line contain the error text.  Example:


          !Error!File'test.c'!line17
          This is a sample error message

          This means, that in file 'test.c' at line 17 an error occurred with
          the description 'This is a sample error message'

    `Warnings'
          Warnings have the same format, except that !Error is replaced by
          !Warning.

    `Any other line'
          is treated as a simple message optionally preceeded by !File and
          !Line.

4.5 Builtin compiler specs
==========================

WARNING: THE LIST OF VARIABLES AND STRINGFUNCTIONS DESCRIBED BELOW MIGHT NOT
BE UPTODATE. IF YOU WANT TO GET INFORMATION ABOUT ALL FEATURES PLEASE LOOK IN
THE SOURCES FOR RHIDE.

RHIDE uses for compiling, linking, and the other stages of generating a file
also specs, like you can change in the local options for a project item (See
Section 3.8.5). Here the specs, which are used currently:

$(RHIDE_COMPILE_C)
     For compiling C source files

$(RHIDE_COMPILE_CC)
     For compiling C++ source files

$(RHIDE_COMPILE_ASM)
     For compiling assembler source files

$(RHIDE_COMPILE_PASCAL)
     For compiling Pascal source files

$(RHIDE_COMPILE_OBJC)
     For compiling objective C source files

$(RHIDE_COMPILE_LINK)
     For linking

$(RHIDE_COMPILE_LINK_PASCAL)
     For linking when the project contain Pascal source files

$(RHIDE_COMPILE_LINK_PASCAL_AUTOMAKE)
     This spec is used only, when you have set the (See Section 3.8.8), to
     tell RHIDE, not to check for dependencies but to use the 'automake'
     feature of GPC.

$(RHIDE_COMPILE_ARCHIVE)
     For creating a library

$(RHIDE_FSDB)
     For calling FSDB.

$(RHIDE_GDB)
     For calling GDB.

$(RHIDE_GPROF)
     For calling GPROF.

$(RHIDE_GREP)
     For calling grep.

All of these specs have a default content in RHIDE, but they can be
overwritten by setting the environment variable with the same name and any
other contents.

4.6 Builtin variables
=====================

This section describes, which variables can be used within RHIDE to get
values from some of the configurations, which you have made inside RHIDE.

All of these variables are referenced by a name enclosed in parentheses
preceeded by a dollar sign. Example: `$(RHIDE_GCC)'. You can overwrite any of
the following variables, if you define in your environment the same variable
with any contents you want.

When RHIDE tries to get the contents of such a variable, it searches at first
if it is found in it's internal database. If it was not found, the environment
is checked for such a variable and if that fails, the resulting value is the
variable itself.

In addition to the use of variables, RHIDE has a limited ability of using
string manipulating functions. I have implemented some of the functions,
which are available with GNU make. They have the same name and should work
exactly like the GNU make counterpart.

`$(strip arg)'
     This function removes any leading and trailing whitespace and converts
     all multispaces to single spaces from the (whitespace separated list)
     `arg'.

`$(addsuffix arg1,arg2)'
     These functions append on each argument from the whitespace separated
     list `arg2' the string `arg1'.

`$(addprefix arg1,arg2)'
     This is the same as `$(addsuffix arg1,arg2)', except that it puts the
     string `arg1' before each argument from `arg2'.

`$(notdir arg)'
     This removes any directory part from the argument `arg'.

`$(dir)'
     This extracts only the directory part from the argument `arg'. If there
     was no directory in `arg', an empty string is returned. (The directory
     contains also the drive letter, if there was one)

`$(subst arg1,arg2,arg3)'
     This replaces every occurrence of `arg1' in `arg3' with `arg2'

The following variables have a special meaning in RHIDE with the default
contents:
$(RHIDE_GCC)
     GCC

$(RHIDE_AS)
     GCC

$(RHIDE_GXX)
     GCC

$(RHIDE_GPC)
     GPC

$(RHIDE_AR)
     ar

$(RHIDE_LD)
     GCC

$(RHIDE_LD_PASCAL)
     GPC

$(RHIDE_ARFLAGS)
     rcs

$(RHIDE_INCLUDES)
     $(SPECIAL_CFLAGS) $(addprefix -I,$(INCLUDE_DIRS))

$(RHIDE_LIBDIRS)
     $(addprefix -L,$(LIB_DIRS))

$(RHIDE_LIBS)
     $(addprefix -l,$(LIBS))

$(RHIDE_LDFLAGS)
     $(SPECIAL_LDFLAGS) $(addprefix -Xlinker ,$(LD_EXTRA_FLAGS))

$(RHIDE_COMPILE_C)
     $(RHIDE_GCC) $(RHIDE_INCLUDES) $(C_DEBUG_FLAGS) \
     $(C_OPT_FLAGS) $(C_WARN_FLAGS) $(C_C_LANG_FLAGS) \
     $(C_EXTRA_FLAGS) $(LOCAL_OPT) -c $(SOURCE_NAME) \
     -o $(OUTFILE)

$(RHIDE_COMPILE_C_FORCE)
     $(RHIDE_GCC) $(RHIDE_INCLUDES) $(C_DEBUG_FLAGS) \
     $(C_OPT_FLAGS) $(C_WARN_FLAGS) $(C_C_LANG_FLAGS) \
     $(C_EXTRA_FLAGS) -x c $(LOCAL_OPT) -c $(SOURCE_NAME) \
     -o $(OUTFILE)

$(RHIDE_COMPILE_CC)
     $(RHIDE_GXX) $(RHIDE_INCLUDES) $(C_DEBUG_FLAGS) \
     $(C_OPT_FLAGS) $(C_WARN_FLAGS) $(C_C_LANG_FLAGS) \
     $(C_CXX_LANG_FLAGS) $(C_EXTRA_FLAGS) $(LOCAL_OPT) \
     -c $(SOURCE_NAME) -o $(OUTFILE)

$(RHIDE_COMPILE_CC_FORCE)
     $(RHIDE_GXX) $(RHIDE_INCLUDES) $(C_DEBUG_FLAGS) \
     $(C_OPT_FLAGS) $(C_WARN_FLAGS) $(C_C_LANG_FLAGS) \
     $(C_CXX_LANG_FLAGS) $(C_EXTRA_FLAGS) -c c++ $(LOCAL_OPT) \
     -c $(SOURCE_NAME) -o $(OUTFILE)

$(RHIDE_COMPILE_ASM)
     $(RHIDE_AS) $(RHIDE_INCLUDES) $(C_DEBUG_FLAGS) \
     $(C_OPT_FLAGS) $(C_WARN_FLAGS) $(C_EXTRA_FLAGS) \
     $(LOCAL_OPT) -c $(SOURCE_NAME) -o $(OUTFILE)

$(RHIDE_COMPILE_ASM_FORCE)
     $(RHIDE_AS) $(RHIDE_INCLUDES) $(C_DEBUG_FLAGS) \
     $(C_OPT_FLAGS) $(C_WARN_FLAGS) $(C_EXTRA_FLAGS) \
     -x assembler $(LOCAL_OPT) -c $(SOURCE_NAME) \
     -o $(OUTFILE)

$(RHIDE_GPC_FLAGS)
     $(RHIDE_INCLUDES) $(C_DEBUG_FLAGS) $(C_OPT_FLAGS) \
     $(C_WARN_FLAGS) $(C_P_LANG_FLAGS) $(C_EXTRA_FLAGS)

$(RHIDE_COMPILE_PASCAL)
     $(RHIDE_GPC) $(RHIDE_GPC_FLAGS) $(LOCAL_OPT) \
     -c $(SOURCE_NAME) -o $(OUTFILE)

$(RHIDE_COMPILE_PASCAL_FORCE)
     $(RHIDE_GPC) $(RHIDE_GPC_FLAGS) -x pascal \
     $(LOCAL_OPT) -c $(SOURCE_NAME) -o $(OUTFILE)

$(RHIDE_COMPILE_LINK)
     $(RHIDE_LD) $(RHIDE_LIBDIRS) $(C_EXTRA_FLAGS) \
     $(RHIDE_LDFLAGS) -o $(OUTFILE) $(OBJFILES) \
     $(LIBRARIES) $(RHIDE_LIBS)

$(RHIDE_COMPILE_LINK_PASCAL)
     $(RHIDE_LD_PASCAL) $(RHIDE_LIBDIRS) $(C_EXTRA_FLAGS) \
     $(RHIDE_LDFLAGS) -o $(OUTFILE) $(OBJFILES) \
     $(LIBRARIES) $(RHIDE_LIBS)

$(RHIDE_COMPILE_LINK_PASCAL_AUTOMAKE)
     $(RHIDE_LD_PASCAL) $(RHIDE_LIBDIRS) $(RHIDE_LDFLAGS) \
     -o $(OUTFILE) \
     --automake=\"$(strip $(RHIDE_GPC_FLAGS))\" \
     $(RHIDE_GPC_FLAGS) $(SOURCE_NAME) $(LIBRARIES) $(RHIDE_LIBS)

$(RHIDE_COMPILE_ARCHIVE)
     $(RHIDE_AR) $(RHIDE_ARFLAGS) $(OUTFILE) $(OBJFILES)

$(RHIDE_FSDB)
     fsdb $(OUTFILE) $(addprefix -p ,$(SRC_DIRS)) $(PROG_ARGS)

$(RHIDE_GDB)
     gdb $(OUTFILE) $(addprefix -d ,$(SRC_DIRS))

$(RHIDE_GREP)
     grep -n $(prompt arguments for GREP)

$(RHIDE_GPROF)
     gprof $(OUTFILE)

The following are not used as real variables, but they are used to get the
contents of options from RHIDE. But you can override them also by setting
them as an environment variable.

$(INCLUDE_DIRS)
     All the include directories

$(LIB_DIRS)
     All the library directories

$(SOURCE_NAME)
     The actual compiled source file

$(OUTFILE)
     The actual created file

$(C_DEBUG_FLAGS)
     All the debugging flags

$(C_OPT_FLAGS)
     All the optimization flags

$(C_WARN_FLAGS)
     All the warning flags

$(C_C_LANG_FLAGS)
     All the C language flags

$(C_CXX_LANG_FLAGS)
     All the C++ language flags

$(C_P_LANG_FLAGS)
     All the Pascal language flags

$(LIBS)
     All the libraries, which are given in the libraries options

$(LD_EXTRA_FLAGS)
     All the additional linker options

$(LOCAL_OPT)
     All the local options for that project item

$(OBJFILES)
     All the destination files, which are part of the project and which are
     not a library and not excluded from linking

$(LIBRARIES)
     All the libraries, which are explicitly included in the project and not
     excluded from linking

$(SPECIAL_CFLAGS)
     Some special flags for `GCC'. Currently only the `-nostdlib' switch.

$(SPECIAL_LDFLAGS)
     Some special flags for `GCC' when linking. Currently only the switches
     `-pg' and `-nostdlib'.

$(prompt TITLE)
     RHIDE prompts for arguments which get the title `TITLE' and insert the
     parameters here.

4.7 Change the defaults of RHIDE
================================

If you have special wishes for compiling your source files, you can configure
for RHIDE mostly everything. For adding support for other than the builtin
known file types (See Section 4.6). If you want to change the behavior of
RHIDE for compiling all the known file types you should know at first really
what you do. If you think, this is a good idea or if you only want only check
if it works you can do it.

Before RHIDE compiles any file (this includes also linking and building a
library) it searches the environment for a variable after the following
scheme: When compiling a file with suffix `.c' to a file with suffix `.o'
RHIDE checks for the variable $(RHIDE_COMPILE.c.o). If this variable is
defined the contents of this variable is taken as the compile spec.

If you want to change the specs for linking you must take as destination
suffix `.exe' or `.' and as source suffix the suffix of your object files.
Example:

$(RHIDE_COMPILE.o.)

4.8 Message window
==================

This window shows every time you compile a file the resulting messages, which
GCC produces. These messages were converted in a special format to show them
in the window. Some of the messages contain a file eventually combined with a
line number. If you press <ENTER> on such a message, the corresponding source
line in the file will be highlighted and the window with this file will be
selected. If this file is not already on the desktop, it will be opened.

If the file, to which the messages refer, is already in the foreground you can
see the selected source line for your messages directly on the screen.

4.9 Syntax highlighting
=======================

Syntax highlighting is now supported directly by the editor. It should work
in mostly every situation for all the supported types. Currently (in RHIDE)
only the C/C++ style syntax highlight and the Pascal style syntax highlight
are supported.

With which style a file is highlighted is chosen by RHIDE by checking the
suffix of the file and determining the file type from that suffix.  (See
Section 2.1)

4.10 Checking the dependencies
==============================

This is one of the main parts of RHIDE. To speed up the work, I have added a
cache for checking the modification time of a file and for finding a file
(computing the full name of a file). But sometimes the data in the cache
isn't valid, especially when running under Windows. If you see this, you can
clear the cache by leaving RHIDE and starting again.

If you didn't do any special things but have problems with it, please run
RHIDE with the `-df' switch and try to find out, where the problem is and
post it to me so I can fix it.

4.11 What is Turbo Vision
=========================

The Turbo Vision library is part of Turbo C++ version 3.1. I have ported this
library to use with DJGPP because I think it is the most powerful text
windowing library, which is available for MS-DOS. With the help of this
library you can write a front end application which looks very well and has
an interface that is easy to use.

The Turbo Vision library is not only a window based text user interface, it
is also a very good event handling mechanism. It supports the use of the
mouse and keyboard with the ability of defining and using of hotkeys.  That
means, you can assign to some key or combinations of keys, which function
should be executed.

The main parts of an application, which is using this library, are the
desktop, the menu bar and the status line. The menu bar is usually shown as
the topmost line of the screen. There are shown the main parts of the pull
down menus, from where you can select the most functions, which are
implemented in an application.

To use the menu you can use the mouse as well the keyboard. With the mouse
you can click every where on a menu entry and the corresponding function will
be executed. There are some different actions, which a menu entry can have.
At first some of them, these are, for example, all the entries in the menu
bar, open a submenu with more menu entries which are related to the name of
this main entry. And the others, most in such a submenu, execute a definite
function of the application.

With the keyboard you can walk through the menu very simply. Press <F10> to
activate the menu bar. In the pull down menus you can use the cursor keys to
move the highlighted bar up and down and with the cursor right and left keys
you can switch to next or previous menu. With the <ENTER> key you activate
the function, which corresponds to this entry. If this was a submenu, which
is indicated with a symbol like a small right arrow, this will be opened.

If you walk through the menu with the cursor keys or the mouse (hold the left
mouse button down and move the mouse) in the status line will be shown for
each entry a short hint for the function of this menu entry.

4.12 How the dialogs work
=========================

In a dialog, like the file open dialog, are many things which you can select
or where you can type in some data. At first some general functions. If you
press <ESC> the dialog will be closed and nothing will be changed. The same
can be done with the mouse by clicking on the close symbol (this is the small
symbol on upper left frame of the dialog).

In the next paragraphs I will describe the most used elements of a dialog.
For selecting each element of a dialog you can use the <Tab> key to select
the next element in the dialog or the `Shift+Tab' key, to select the previous
element.

A button is a rectangle with some text on it. If you activate such a button a
specified action is executed. To select a button you can use the <Tab> key,
until the button is specially highlighted and press <ENTER> then. Most times
a character of the text on this button has a different color. So you can
press <Alt> plus this character to activate the button. With the mouse you
can simply click on a button to activate it.

A Listbox is a collection of some strings in one or more columns and rows as
needed. The project window (See Section 3.10.9 window) is such a Listbox with
the names of the project items. You can use the cursor keys to move the focus
bar in the list, or if it is a sorted Listbox, you can also type some
characters and the focus will move to the item, which starts with these
characters. To select a item in a list box, press <SPACE> or <ENTER> or
double click with mouse on it.

In an input line you can type some text which can be edited with the usual
editing keys.

A checkbox is a collection of options, which can be turned on or off.  Each
option has in front of it a small indicator, if it is turned on (an X is
shown) or not (the X is not shown). To toggle such an option, use the cursor
keys to move the focus to the option you want and press <SPACE> or, if a
character in an option string is highlighted you can press this key and the
option will be turned on or off or click with the mouse on the option.

Radiobuttons are similar to Checkboxes, but there you can select only one of
all the shown options.

4.13 Defining macros
====================

Please look for a detailed documentation here: See Documentation about Pseudo
Macros in "SET's editor", or point your Web browser to http://editor.html

4.14 The INFO Viewer
====================

The integrated help system of RHIDE is based on the INFO Viewer written by
Salvador Eduardo Tropea (SET) <ice@inti.edu.ar>. It gives you access to all
the INFO files which you have installed in the correct directories as is done
for `info.exe'.

To get help about the INFO Viewer hit <F1> when the help-window is opened or
follow this link to See Section 'Top' in documentation for 'The Info Viewer'.

In addition to getting help with this system you can also copy text from the
help screen to the clipboard. This is useful if you want for instance to copy
an example from the libc reference in your program. This feature is not so
powerful as in the editor, but it is good enough. To mark some text use the
<Shift> and cursor keys and copy the selected text with `Ctrl+Ins' to the
clipboard.

In RHIDE you have also the possibility to get help about a specific function.
Currently this works only for functions, which are documented in the libc
reference. For doing this, move the cursor to the function and hit <Ctrl+F1>
or click with the right button of the mouse on that word.

4.15 RCS and RHIDE
==================

RHIDE knows a little bit about RCS, the Revision Control System. Since RCS is
available also for DJGPP I enabled now some features to use RHIDE also on
packages which use RCS.

RHIDE can handle RCS files in the way, that it searches for a checked in
source file if the normal source file was not found. The complicatest part
here was to determin the correct RCS file name from the source name.
(Especially under DJGPP this is a problem since under raw DOS it is not
possible to use names like 'foo.c,v').

So I decided to use the external program `rlog' which comes with the RCS
package to determine the actual correct RCS source name. I did so because the
DJGPP implementation knows enough about the DOS limitation and how to solve
them.

This help here is not ment to be a RCS introduction. If you don't know what
RCS is or what can be done with it, please look in the manuals wich come with
RCS.

Here now what RHIDE knows about the RCS files. If a source file was not
found, it's RCS name is computed with the spec `$(RHIDE_RLOG)' which defaults
to `$(shell rlog -R $(rlog_arg))' where `$(rlog_arg)' is substituted at
runtime with the actual wanted source file.

This spec can be overwritten to speed it up. An example for this can be found
in the distributed sample environment file `rhide_.env'.

When RHIDE only wants to compile the file or only to get the modification
time it is temporary checked out (without locking it) and after the needed
operation (compiling) it is removed (for checking the modification time it is
not checked out, but the time form the RCS file is taken).

If you want to open that file for editing the same is done but now it is
checked out with setting a lock and it is not checked in after closing the
window. The spec for checking the file out is `$(RHIDE_CO)' which can be
overwritten also and it defaults to `$(shell co -q $(co_arg))' where the
switch `-l' is added when it is checked out for edititing otherwise
`$(co_arg)' is substituted at runtime only with the wanted source file.

5. Debugging with RHIDE
***********************

For debugging your programs you need now no external debugger, because RHIDE
has one integrated. The integrated debugger is not code which I have written,
but it is GDB 4.16, which is linked in RHIDE.

Because RHIDE uses a special method to communicate with GDB it is currently
not possible to use all of the features, which GDB has. I have implemented at
this time the most important functions, which are needed to debug your
program. So it is not possible to give GDB the same commands as when running
GDB stand alone. That means, if you need any very special feature of GDB you
must run GDB.

The integrated debugger is a real source level debugger like GDB. If you step
through your program you will see every time exactly where in the sources you
are. But to use the ability to debug your program needs, that you have
compiled your source files with debugging information and these symbols must
not have been stripped from the executable.

5.1 Limitations of the integrated debugger
==========================================

Because the integrated debugger is GDB, you will have all the limitations
which GDB has in addition to well known DJGPP and/or MS-DOS limitations.
Here is a (not complete) list of known misfeatures:

   * Signals are not correctly handled every time by distinguishing between
     the debuggee and RHIDE

   * Remote debugging is NOT supported

   * Debugging of graphic programs may work or not depending on the software
     you are using. Currently only the VESA modes and the standard VGA
     graphic modes are supported.

   * When using the integrated debugger under Windows 3.1x (in Windows 95
     there is no such limitation) the number of breakpoints is limited to 3,
     because you can use there only hardware breakpoints. The i386 supports
     only 4 hardware breakpoints and 1 is needed for internal use.  This is a
     common problem for all DJGPP debuggers. (Try to use FSDB with more than
     3 breakpoints under Windows 3.1x)

   * Sometimes the source line, which is shown by RHIDE in assuming that the
     execution is there, is not correct. But this is NOT a bug of RHIDE and
     NOT of GDB. This is a bug in GCC which produces wrong line number
     information in the object files. Here is a very simple test program,
     with which you can see this problem.

          /* This is an example, that GCC produces wrong line number
             information for code which is optimized out. (compile this
             with -O) */
          
          int a = 1;
          int b = 2;
          
          int main()
          {
            if (a == b) return 0;
            if ((a + 1) == b) return 1;
            return 0; /* The debugger should never come here,
                         but it comes */
          }

5.2 Dual display debugging
==========================

RHIDE supports now also to use an installed dual display. This is when you
have installed in addition to your VGA card a monochrome display card
together with a monitor. RHIDE checks this by asking the BIOS if it is
present and if this is true and the option is enabled (See Preferences) then
RHIDE switches automatically to the secondary display when debugging and your
program will run on the primary display.

With this debugging technique you will get the best debugging results
especially when debugging graphics programs.

To use the dual display with RHGDB use the `-D' switch for RHGDB.

5.3 Using the integrated debugger
=================================

If you are familiar with Borland's debugger, you will see, that most of the
functions of that debugger are implemented in the same or in a similar way
(this includes the key bindings).

5.3.1 Stepping through the source code
--------------------------------------

For stepping through your code, there are three ways. This is at first the
Step-function <F8>. With this you execute a complete source line. If there is
a function call at the current execution point, this function is called
without debugging it. This technique is the same like the `next'-command from
GDB.

The next way is the Trace-function.  It is like the Step-function, <F7>,
except that if there is a function call at the current execution point, you
will go into this function when there is debugging information for that
function available.  This technique is the same as the `step'-command from
GDB.

And the third way is the Goto-Cursor-function. For this, move the cursor to
the line in your source code and press <F4>. Now the execution of your
program is continued until it comes to that line. Sometimes you will get an
error message, that for the specified line is no code generated.  This comes
from the optimization of your code by GCC. In this case try a line below or
above.

5.3.2 Evaluating the contents of variables
------------------------------------------

You can evaluate also the the contents of variables, when your program has
been started. For this you can press `Ctrl+F4' and you will see a dialog,
where you can type in the expression to evaluate, a line with the result and
a line, where you can give the expression a new value. If you have pressed
this in an editor window, RHIDE tries to find the word under the cursor and
copies this as default in the expression input line. To get the contents of
this expression you have to press the *Evaluate*-button.

If the expression could not be evaluated so it is shown in the result line.
For the exact syntax of getting the contents of an expression See Section
'Expressions' in documentation for 'gdb'. You can also show the value of the
expression in several formats, See Section 'Output Formats' in documentation
for 'gdb'.

In addition to the functionality of the Borland debuggers, GDB (and of course
also RHIDE) can evaluate the result of function calls. If you have, for
example, in your debugged program a function
     int foo(int arg1)
     {
     /* do something and return a value */
     }
defined, you can type in the expression input line
     foo(16)
and you will get as result, what the function would return, if it is called
with the argument `16'. As arguments you can also use any known variable or
complex expressions.

A known limitation is, that the expressions are NOT checked for validity.
That means, you can produce any exception there, which will terminate your
program. As an example type in the expression input line
3/0
And, of course, you cannot assign to a function call a new value.

As an special side effect you can use this also as a calculator. You can
evaluate any trivial or complex expression and this is also available, if you
haven't started the integrated debugger.

5.3.3 Watching the contents of variables
----------------------------------------

In addition to a single look at the contents of a variable, you can add the
variable to a list which is updated after each debugger step and is shown in
the watching window. For this function you can use the hotkey `Ctrl+F7'.

Within the watch window you can press <Enter> on an expression to change that
expression (NOT the contents of that expression) or you can press <Del> to
remove the variable from the watch window.

5.4 Problems with C++ programs
==============================

Because GDB cannot handle correctly C++ debugging information when it is
generated as COFF debugging information (with stabs debugging information
there is no such limitation and you can skip reading more) you will have many
problems when debugging C++ programs to get the contents of a variable when
it is a member of a class. Because GDB does not detect, that your program is
a C++ program, it sees it as a normal C program and so GDB does nothing know
about classes and all what have to do with it.

For accessing the member of a baseclass you must do some tricks. Let me
explain it on an example:

     class A
     {
     public:
       int a;
     };
     
     class B : public A
     {
     public:
       void test();
     };
     
     void B::test()
     {
       fprintf(stdout,"%d\n",a);
     }

If you debug the program in the function `B::test()' and you want to get the
contents of the member `a', you have to access it with `this->A.a' !!! That
means: At first you must access all members with the implicit `this' variable
and at second you must give all baseclasses until that, where the member was
declared.

5.5 Using Breakpoints
=====================

Breakpoints are a very useful thing when debugging a program. You can set a
breakpoint at any location of your program and run it. It will be
automatically stopped, if the program execution reaches the breakpoint.

5.5.1 Setting a breakpoint
--------------------------

For setting a breakpoint there are two different ways. The first is by
setting a breakpoint at any line by pressing `Ctrl+F8'. You will see, that
there is a breakpoint set, that this line is shown in another color. If you
hit `Ctrl+F8' on a line, which has already a breakpoint, the breakpoint at
this line is removed.

5.5.2 Modifying and setting a breakpoint
----------------------------------------

The second way is by setting a breakpoint with the breakpoint dialog which is
selectable only from the menu. There you will see any breakpoint for your
program. These breakpoints can be modified now in many things.  In this
dialog you can enable/disable a breakpoint. This is not the same as deleting
and resetting it. If you disable a breakpoint, it is stored internally but it
is not used. If you enable it again all the settings for that breakpoint,
which you have already made, are remembered.

In the breakpoint dialog you can also set or delete a breakpoint with the
given buttons. If you want to set a new breakpoint, use the New-Button. Then
you will get a dialog which you also get when you press the Modify-Button. In
this dialog you can change many things of the breakpoint.

In this dialog is the only point for setting a breakpoint at a specified
function. For doing this you must set at first the type of the breakpoint to
Function. Then you can type in the function input line the name of the
function or hit <Ctrl+F1> to get a list of functions which are available from
where you can select one with <Enter>.

For setting a breakpoint at a specified line, set the breakpoint type to Line
and type in the filename and the linenumber.

The next what you can modify on a breakpoint is a condition. That means that
the breakpoint should stop your program only, if the condition is true. Write
the condition in the programming language of your source file and you can use
any accessible variable and you can call also functions of the debugged
program. For other information about the syntax See Section 'Conditions' in
documentation for 'gdb'.

And at last you can give your breakpoints also a count. A breakpoint count is
a number, how often this breakpoint is ignored. That means, if you type
there, for example, `10', then the RHIDE stops the execution of the program
only, if it comes to that point the tenth time. WARNING: This count is set by
RHIDE only once. After the breakpoint is really hit, from now on the
breakpoint stops your program every time, the breakpoint is reached.

5.5.3 Problems with breakpoints
-------------------------------

Currently there is a big problem, when you have set a breakpoint at a line
(not at a function) of your program and you edit now the source code. If you
insert or delete some lines the breakpoints, which are set at lines after or
at the modified lines are NOT updated to the correct line number.

6. Debugging with RHGDB
***********************

In addition to RHIDE, which has an integrated debugger, there is also a
stand-alone debugger called RHGDB. (The name comes from my initials and GDB)

RHGDB has the same abilities as RHIDE for debugging your program. But it has
no editor. The source files are shown in read only windows where you can move
the cursor and other things (except editing) like in RHIDE.

The menu tree is analog of RHIDE's but (of course) it has not all the menu
entries of RHIDE, because RHGDB should be used only for debugging and nothing
else.

I have written it to debug DJGPP programs, for which there is no RHIDE
project file available but the program has debugging information and, if you
are short of memory, it is much smaller than RHIDE.

The syntax for using RHGDB is very simple. Run it with your program as the
first argument followed by any argument, which should be passed to your
program.

RHGDB saves and reads the options from files with the suffix `.rgd'.  This is
done automatically when you run RHGDB with your program as argument by
searching a file with the same basename of your program and the suffix `.rgd'
and in this file the options are also automatically stored, when you exit
RHGDB.

Alternatively you can also save/read the options from within RHIDE by
selecting the corresponding menu entries from the Options menu.

To use the the "Dual display debugging" feature of RHGDB you must give on
commandline the `-D' switch.

7. Some FAQs
************

**Question*: I have enabled the `Use tabs' option, but if I move the cursor
through that tab, it seems, that RHIDE uses spaces*

*Answer*:This behavior cannot (currently) be changed. Even when you have
enabled the use of real tabs (characters with the code 9), the cursor is
moved as if there are spaces.

**Question*: Are there any sample project files, to show how RHIDE works?*

*Answer*:The sources of RHIDE include many project files to rebuild at least
RHIDE with itself and many others.

**Question*: I have written some libraries. How can I use them in a project?*

**Question*: How I can use a library, which I have?*

*Answer*: There are some different ways to do this. On the one side you can
include them directly in the project with the *Add to project item* function
(See Section 3.8.3). But if they are not in the current directory, you must
also set the library search path to the directory, where they are. (See
Section 3.9.1.2). The other variant is to include them in the list of
libraries. (See Section 3.9.3)

If this library is created with RHIDE, that means you have a project file for
building this library you can also simply include that project file in your
project. For examples, look at the RHIDE sources in the project file for
RHIDE.

**Question*: I have a directory, where all my include files are. Can I setup
RHIDE to have this directory every time in the include search path, when
creating a new project?*

**Question*: I prefer the 80x28 video mode over the default 80x25 mode. How I
can turn this mode on by default for all newly created project files?*

*Answer*: You can create a default project file. From this file RHIDE reads
all the options, if it creates a new project. The default project must have
the same basename as the executable of RHIDE and must be located in the same
directory.

The creation of such a default project file is very simple. Change to the
directory, where `rhide.exe' is located and run there
     rhide rhide

Now make any changes in the options which you want to have as default for all
newly created projects. This includes also settings in the various search
paths. If you are ready, exit RHIDE and this project file will be your
default project file.

**Question*: I know, that I can create a default project file. Can I create
and use more than one?*

*Answer*:Since DJGPP supports a quasi-Unix-like link for executables, you can
create such a link also for RHIDE. As an example I will create a link to
`rhide.exe' with the name `myrhide.exe'. At first I have to create the new
file.
     stubify -g myrhide.exe
Now I must tell `myrhide.exe' which program it really should run.
     stubedit myrhide.exe runfile=rhide
Thats all. Or, if you have installed the GNU fileutils, you can use also now
the `ln.exe' program to create the link:
     ln -s rhide.exe myrhide.exe

**Question*: I don't want to type every time I start RHIDE the commandline -L
DE to use the German user interface. Is there any better way?*

*Answer*: Create an environment variable LANGUAGE with your preferred
language like
     set LANGUAGE=de
and your problem is solved.

**Question*: I have 4 Mb RAM in my computer and every time, when I compile
large files with optimizations enabled, my hard disk is working very hard.*

*Answer*:Buy more RAM!

**Question*: I heard something about a newer version RHIDE. From where I can
get exact information about this?*

*Answer*: See at the RHIDE home page, at this URL:

     http://www.tu-chemnitz.de/~rho/rhide.html

.  (valid until at least 30. Sepetember 1997) This page contains the latest
news and the latest version of RHIDE.

**Question*: I have a lot of money and don't know what to do with it. Can you
help me?*

*Answer*: Send it to me, so I can spend more time for developing RHIDE. My
Address is:
     Robert H”hne
     Am Berg 3
     D-09573 Dittmannsdorf
     Germany

**Question*: I think, I found a bug in RHIDE. How can I report it?*

*Answer*:At first try for your own to solve the problem by checking the
documentation.

If the bug is releated to the editor (some keys do not work, autoindenting is
not like you expect, program creash after some special editing ....) please
send them to Salvador Eduardo Tropea (SET) <ice@inti.edu.ar>, because he is
the author of the in RHIDE integrated editor.

See at the RHIDE home page, at this URL:

     http://www.tu-chemnitz.de/~rho/rhide.html

(valid until at least 30. September 1997), if this problem was already
reported by other users. As the next ask the problem in the news group
comp.os.msdos.djgpp Newsgroup, because there may be some other people with
the same problem, and they can give you an answer or I, because I read this
group also.

Linux users should post thier problems in the linux group. To make sure that
I will read it there also, please include in the subject anywhere the word
RHIDE so I will find it, because I do not read any article there because the
group is too heavily used. Currently I do only a subject search for the word
RHIDE and if not found I mark the group as readed by me. Sorry for this, but
compared with the very good comp.os.msdos.djgpp group the linux groups are
too large for seriously diskussion (at least for me).

If this don't help you, do the following:

     Try to reproduce the error with the smallest possible project or source
     file. Run RHIDE with all debugging options enabled and redirect the
     printed output to a file. (See Section 1.5.2) Send me this file and a
     detailed as possible description of the problem and include in your
     report the exact version of RHIDE you are using.

     The exact version is shown in the About-Dialog and means the version
     number together with the build date.


And a last note. If I get bug reports or questions or problems with RHIDE
which I think that they are of common interest be warned that I bounce them
simply to the news groups because at this time it is impossible for me to
answer all the mails I get. So the best is to post the questions and/or
problems only in the news groups.

8. Index
********



* Adding a file to the project: Section 3.8.3.
* Additional options for GCC: Section 3.9.5.
* Arguments for your program: Section 3.5.6.
* Assembler files, which must be preprocessed: Section 2.1.
* Automatic dependencies: Section 3.9.1.5.
* Automatic dependencies, problems with it: Section 4.3.1.
* Automatic indention:                   autoindent.
* Automatic intention:                   Intelligent C indenting.
* Background colors, 16:                 16 background colors.
* Backup files:                          create backup files.
* Blinking colors:                       16 background colors.
* block commands: Section 4.2.4.
* Bug report: Section 3.1.2.
* Bug, reporting it: Chapter 7.
* Build: Section 3.6.4.
* Build the library: Section 3.6.3.
* Building a library: Section 3.8.7.
* Building an executable: Section 3.8.7.
* Builtin calculator: Section 5.3.2.
* Button: Section 4.12.
* C Flags, edit them: Section 3.9.6.7.
* C language specific flags: Section 3.9.2.4.
* C++ flags, edit them: Section 3.9.6.8.
* Caching of files:                      No file caching.
* Calculator: Section 3.1.7.
* Call stack: Section 3.7.6.
* Cascade the windows: Section 3.10.4.
* Changing the name of the library: Section 3.8.7.
* Changing the name of the program: Section 3.8.7.
* Changing the search paths for files: Section 3.9.1.
* Checkbox: Section 4.12.
* Checking dependencies: Section 4.10.
* Clear: Section 3.3.7.
* Clearing the dependencies: Section 3.8.9.
* Clearing the project: Section 3.8.10.
* Clipboard: Section 3.3.6.
* Close a project: Section 3.8.2.
* Close a window: Section 3.10.7.
* COFF file, Creating: Section 3.8.7.
* Colors: Section 3.9.6.1.
* Column cursor:                         Column cursor.
* Commandline arguments for your program: Section 3.5.6.
* Commandline options: Section 1.5.
* Compile: Section 3.6.1.
* Compile without a project: Section 4.3.
* Compiler options: Section 3.9.5.
* COMSPEC: Section 3.2.6.
* Configuring RHIDE <1>: Section 4.7.
* Configuring RHIDE: Section 1.2.1.
* Context help: Section 4.14.
* Controlling the optimization of the code: Section 3.9.2.2.
* Controlling the warnings: Section 3.9.2.1.
* Copy: Section 3.3.4.
* Copy to Windows clipboard: Section 3.3.8.
* Cplusplus options: Section 3.9.2.5.
* Creating a COFF file: Section 3.8.7.
* Creating a makefile <1>: Section 3.8.11.
* Creating a makefile <2>:               all dependencies in makefile.
* Creating a makefile: Section 1.6.
* Creating a new file: Section 3.2.2.
* Creating a new project: Section 3.8.1.
* Creating backup files:                 create backup files.
* Cross cursor <1>:                      Column cursor.
* Cross cursor:                          Row cursor.
* Cursor moving: Section 4.2.2.
* Cursor through tabs: Chapter 7.
* Cut: Section 3.3.3.
* CXX options: Section 3.9.2.5.
* Debugging: Section 1.5.2.
* Debugging info: Section 3.9.2.3.
* Debugging RHIDE <1>:                   Show GDB commands.
* Debugging RHIDE:                       show process information.
* Debugging with RHIDE: Section 3.7.
* Debugging, dual display:               Use dual display.
* Debugging, edit the flags: Section 3.9.6.12.
* Default file mask: Section 3.2.1.
* Default language: Chapter 7.
* Default project file: Chapter 7.
* Default project file, more than one: Chapter 7.
* Define your own reserved words: Section 3.9.6.14.
* Defines: Section 3.9.5.
* Delete a file from the project: Section 3.8.4.
* Delete the selected text: Section 3.3.7.
* Deleting commands: Section 4.2.1.
* Dependencies for a file: Section 3.8.6.
* Dependencies in makefile:              all dependencies in makefile.
* Dependencies, checking: Section 4.10.
* Dependencies, problems with it: Section 4.3.1.
* Dialog function keys: Section 4.12.
* Different name for RHIDE: Chapter 7.
* Directory for temp files: Section 2.3.
* Disable shadows:                       Use no shadows.
* Disassembler: Section 3.7.5.
* Donations to the author: Chapter 7.
* DOS: Section 3.2.6.
* Dual display: Section 5.2.
* Dual display when debugging:           Use dual display.
* Dual display with RHGDB: Chapter 6.
* Edit a file: Section 3.2.1.
* Edit the list of C flags: Section 3.9.6.7.
* Edit the list of C++ flags: Section 3.9.6.8.
* Edit the list of debugging flags: Section 3.9.6.12.
* Edit the list of Fortran flags: Section 3.9.6.10.
* Edit the list of optimization flags: Section 3.9.6.13.
* Edit the list of Pascal flags: Section 3.9.6.9.
* Edit the list of reserved words: Section 3.9.6.5.
* Edit the list of reserved words for Pascal: Section 3.9.6.6.
* Edit the list of user defined words: Section 3.9.6.14.
* Edit the list of warning flags: Section 3.9.6.11.
* Editor: Section 4.2.
* Editor options: Section 3.9.6.2.
* Editor, block commands: Section 4.2.4.
* Editor, cursor moving: Section 4.2.2.
* Editor, erasing commands: Section 4.2.1.
* Editor, other useful commands: Section 4.2.5.
* Editor, select some text: Section 4.2.3.
* Environment variables <1>: Section 3.9.1.
* Environment variables <2>: Section 1.8.
* Environment variables: Section 1.8.1.
* Erasing commands: Section 4.2.1.
* Executing your program: Section 3.5.1.
* Exit: Section 3.2.7.
* Expanding tabs: Section 3.3.10.
* File caching:                          No file caching.
* File open dialog: Section 3.2.1.
* Files for syntax help: Section 3.11.3.2.
* Finding text: Section 3.4.1.
* Flags for C files: Section 3.9.2.4.
* Flags for C++ files: Section 3.9.2.5.
* Flags for Fortran files: Section 3.9.2.7.
* Flags for Pascal files: Section 3.9.2.6.
* Fortran flags, edit them: Section 3.9.6.10.
* Fortran options: Section 3.9.2.7.
* Free memory:                           show free memory.
* Function call stack: Section 3.7.6.
* Generating of warnings: Section 3.9.2.1.
* Global editor options: Section 3.9.6.2.
* Goto a line number: Section 3.4.4.
* GPC, -automake: Section 3.8.8.
* Header files: Section 3.9.1.1.
* Help: Section 3.11.1.
* Help about a function: Section 3.11.3.1.
* Help about help: Section 3.11.6.
* Help about the Info-viewer: Section 3.11.6.
* Help system: Section 4.14.
* Highlight the syntax: Section 4.9.
* Highlighting the matching parenthesis: Match pair highlight.
* Highlighting the syntax:               syntax highlighting.
* Hints: Section 4.3.
* How the editor works: Section 4.2.
* Include directories: Section 3.9.1.1.
* Include files: Section 3.9.1.1.
* Info Viewer: Section 4.14.
* Input line: Section 4.12.
* Intelligent C indenting:               Intelligent C indenting.
* Language, setting the default: Chapter 7.
* Languages: Section 1.5.1.
* Latest version of RHIDE: Chapter 7.
* Leaving RHIDE: Section 3.2.7.
* LFN: Section 2.3.
* Libc reference: Section 3.11.5.
* Libraries: Section 3.9.3.
* Libraries in a project: Chapter 7.
* Library search path: Section 3.9.1.2.
* Link the program: Section 3.6.3.
* Linker options: Section 3.9.4.
* Linux: Section 2.6.
* List of all windows: Section 3.10.8.
* Listbox: Section 4.12.
* Lists: Section 4.12.
* Load options <1>: Section 3.9.8.
* Load options: Section 2.7.3.
* Loading a file: Section 3.2.1.
* Local options: Section 4.4.4.
* Local options for a project item: Section 3.8.5.
* Long filenames: Section 2.3.
* Macro executing: Section 3.3.12.3.
* Macro recording: Section 3.3.12.1.
* Macro stop recording: Section 3.3.12.2.
* Macros <1>: Section 4.13.
* Macros: Section 3.3.12.
* Main targetname: Section 3.8.7.
* Make: Section 3.6.2.
* Make clear: Section 3.8.10.
* Makefile: Section 3.8.11.
* Mark some text: Section 4.2.3.
* Message window: Section 4.8.
* Miscellaneous commands: Section 4.2.5.
* Mouse options:                         Mouse options.
* Moving a window: Section 3.10.1.
* MS-DOS: Section 3.2.6.
* Name of the main target: Section 3.8.7.
* Next message: Section 3.4.6.
* Next window: Section 3.10.5.
* No shadows:                            Use no shadows.
* Object file search path: Section 3.9.1.3.
* Object files in a different directory: Section 3.9.1.3.
* Open a file: Section 3.2.1.
* Open a project: Section 3.8.1.
* Optimal filling:                       Optimal fill.
* Optimizations, edit the flags: Section 3.9.6.13.
* Optimizing the code: Section 3.9.2.2.
* Options for a single file: Section 3.8.5.
* Options for the linker: Section 3.9.4.
* Order of the project items: Section 4.4.1.
* OS/2: Section 2.4.
* Other compilers: Section 4.7.
* Pascal flags, edit them: Section 3.9.6.9.
* Pascal options: Section 3.9.2.6.
* Pascal reserved words: Section 3.9.6.6.
* Paste: Section 3.3.5.
* Paste from Windows clipboard: Section 3.3.9.
* Persistent blocks:                     Persistent blocks.
* Playing the macro: Section 3.3.12.3.
* Preprocessing Assembler files: Section 2.1.
* Previous message: Section 3.4.7.
* Previous window: Section 3.10.6.
* Problems: Section 4.3.
* Project window: Section 4.4.
* Pseudo Macros: Section 4.13.
* Quit: Section 3.2.7.
* Radiobuttons: Section 4.12.
* RCS: Section 4.15.
* Rebuilding RHIDE: Chapter 7.
* Redirecting stderr:                    redirect stderr.
* Redirecting stdout:                    redirect stdout.
* Redo: Section 3.3.2.
* Remove a file from the project: Section 3.8.4.
* Removing all targets: Section 3.8.10.
* Removing the internal dependencies: Section 3.8.9.
* Repeat of replacing: Section 3.4.3.
* Repeat of searching: Section 3.4.3.
* Replacing text: Section 3.4.2.
* Reporting bugs <1>: Chapter 7.
* Reporting bugs: Section 3.1.2.
* Reserved words: Section 3.9.6.5.
* Resizing a window: Section 3.10.1.
* Reverse mouse buttons:                 Mouse options.
* RHIDE project files: Chapter 7.
* RHIDE, latest version: Chapter 7.
* rhide.env: Section 1.8.1.
* rhide.env, Samples: Section 1.8.1.
* Row cursor:                            Row cursor.
* Running your program: Section 3.5.1.
* Sample projects: Chapter 7.
* Save all files to disk: Section 3.2.5.
* Save options <1>: Section 2.7.3.
* Save options:                          Save options.
* Save the file to disk: Section 3.2.3.
* Save the file under a different name: Section 3.2.4.
* Search a function: Section 3.4.5.
* Search path for include files: Section 3.9.1.1.
* Search path for libraries: Section 3.9.1.2.
* Search path for object files: Section 3.9.1.3.
* Search path for source files: Section 3.9.1.4.
* Searching text: Section 3.4.1.
* Searchmethod for syntax help: Section 3.11.3.3.
* Select a window: Section 4.1.
* Select the project window: Section 3.10.9.
* Selecting some text: Section 4.2.3.
* Show free memory:                      show free memory.
* Show the includes for a file: Section 3.8.6.
* Show the project window: Section 3.10.9.
* Show the user screen: Section 3.10.10.
* Show what RHIDE does:                  show process information.
* Single file compiling: Section 4.3.
* Size for the tabs:                     Tabsize.
* Source file search path: Section 3.9.1.4.
* Source files in a different directory: Section 3.9.1.4.
* Space as part of an argument: Section 2.2.
* Specs: Section 1.8.1.
* Standard headers: Section 3.9.1.5.
* Start: Section 1.5.
* Starting a macro: Section 3.3.12.1.
* Starting your program: Section 3.5.1.
* stderr redirecting:                    redirect stderr.
* stdout redirecting:                    redirect stdout.
* Stopping a macro: Section 3.3.12.2.
* Store a file: Section 3.2.3.
* Suppressing of warnings: Section 3.9.2.1.
* Syntax help: Section 3.11.3.1.
* Syntax help, Index:                    Index for syntax help.
* Syntax help, Options: Section 3.11.3.3.
* Syntax highlighting <1>:               syntax highlighting.
* Syntax highlighting: Section 4.9.
* Tab size:                              Tabsize.
* Tabs:                                  Use tabs.
* Tabs to spaces: Section 3.3.10.
* Temp directory: Section 2.3.
* temporary do to DOS: Section 3.2.6.
* Text mode:                             Screen mode.
* Tile the windows: Section 3.10.3.
* Transparent blocks:                    Transparent Blocks.
* Turbo Vision: Section 4.11.
* Type of the main target: Section 3.8.7.
* Undo: Section 3.3.1.
* Use of libraries: Chapter 7.
* User defined compiler:                 User defined compiler.
* User defined reserved words: Section 3.9.6.14.
* User screen: Section 3.10.10.
* Using the dialog: Section 4.12.
* Using the macro: Section 3.3.12.3.
* Using true tabs:                       Use tabs.
* Version of RHIDE: Section 3.1.1.
* Video mode:                            Screen mode.
* Warnings: Section 3.9.2.1.
* Warnings, edit the flags: Section 3.9.6.11.
* Window, close it: Section 3.10.7.
* Window, moving: Section 3.10.1.
* Window, resizing: Section 3.10.1.
* Window, select it: Section 4.1.
* Window, select the next: Section 3.10.5.
* Window, select the previous: Section 3.10.6.
* Window, zoom it: Section 3.10.2.
* Windows: Section 3.10.
* Windows 95: Section 2.3.
* Windows, cascade them: Section 3.10.4.
* Windows, show a list of all: Section 3.10.8.
* Windows, tile all: Section 3.10.3.
* Write a makefile: Section 3.8.11.
* xterm, running RHIDE in it: Section 2.6.
* Zoom a window: Section 3.10.2.

9. Index of key commands
************************



* <Alt+0> | List of all windows: Section 3.10.8.
* <Alt+Backspace> | Undo: Section 3.3.1.
* <Alt+F10> | Macro stop: Section 3.3.12.2.
* <Alt+F2> | Jump to function: Section 3.4.5.
* <Alt+F3> | Close a window: Section 3.10.7.
* <Alt+F5> | User screen: Section 3.10.10.
* <Alt+F7> | Previous message: Section 3.4.7.
* <Alt+F8> | Next message: Section 3.4.6.
* <Alt+F9> | Compile: Section 3.6.1.
* <Alt+SPACE> | System Menu: Section 3.1.
* <Alt+X> | Leaving RHIDE: Section 3.2.7.
* <Alt> | Selecting a window: Section 4.1.
* <Backspace> | Erase a character: Section 4.2.1.
* <Ctrl+A> | Word left: Section 4.2.2.
* <Ctrl+Backspace> | Delete to the previous word: Section 4.2.1.
* <Ctrl+Break> | Interrupting the compilers: Section 1.3.
* <Ctrl+C> | Ignoring: Section 1.3.
* <Ctrl+C> | Page down: Section 4.2.2.
* <Ctrl+D> | Cursor right: Section 4.2.2.
* <Ctrl+Del> | Delete selected text: Section 4.2.3.
* <Ctrl+E> | Cursor up: Section 4.2.2.
* <Ctrl+F10> | Macro play: Section 3.3.12.3.
* <Ctrl+F1> | Context help: Section 4.14.
* <Ctrl+F1> | List of functions: Section 5.5.2.
* <Ctrl+F1> | Syntax help: Section 3.11.3.1.
* <Ctrl+F2> | Program reset: Section 3.5.5.
* <Ctrl+F3> | Call stack: Section 3.7.6.
* <Ctrl+F4> | Evaluate/Modify: Section 3.7.2.
* <Ctrl+F5> | Resize/move a window: Section 3.10.1.
* <Ctrl+F7> | Watch an expression: Section 3.7.3.
* <Ctrl+F8> | Toggle a breakpoint: Section 3.7.1.
* <Ctrl+F9> | Run: Section 3.5.1.
* <Ctrl+F> | Word right: Section 4.2.2.
* <Ctrl+G> | Delete a character: Section 4.2.1.
* <Ctrl+H> | Delete a character: Section 4.2.1.
* <Ctrl+I> | Show includes: Section 3.8.6.
* <Ctrl+Ins> | Copy <1>: Section 4.2.3.
* <Ctrl+Ins> | Copy: Section 3.3.4.
* <Ctrl+J> | Goto line: Section 3.4.4.
* <Ctrl+J> | Jump to a line: Section 4.2.5.
* <Ctrl+K+?> | Set a marker: Section 4.2.5.
* <Ctrl+K+B> | Start of block: Section 4.2.4.
* <Ctrl+K+C> | Paste: Section 4.2.3.
* <Ctrl+K+H> | Unselect: Section 4.2.3.
* <Ctrl+K+I> | Indent block: Section 4.2.4.
* <Ctrl+K+K> | Copy: Section 4.2.3.
* <Ctrl+K+K> | End of block: Section 4.2.4.
* <Ctrl+K+M> | To upper: Section 4.2.4.
* <Ctrl+K+O> | To lower: Section 4.2.4.
* <Ctrl+K+R> | Read block from file: Section 4.2.4.
* <Ctrl+K+Shift+Tab> | Block unindenting: Section 4.2.4.
* <Ctrl+K+Tab> | Block indenting: Section 4.2.4.
* <Ctrl+K+U> | Unindent block: Section 4.2.4.
* <Ctrl+K+V> | Move block: Section 4.2.4.
* <Ctrl+K+W> | Write block to file: Section 4.2.4.
* <Ctrl+K+Y> | Cut: Section 4.2.3.
* <Ctrl+L> | Again find/replace: Section 4.2.3.
* <Ctrl+L> | Search again: Section 3.4.3.
* <Ctrl+O> | Auto indent: Section 4.2.5.
* <Ctrl+O> | Local options <1>: Section 4.4.4.
* <Ctrl+O> | Local options: Section 3.8.5.
* <Ctrl+PgDown> | Bottom of file: Section 4.2.2.
* <Ctrl+PgUp> | Begin of file: Section 4.2.2.
* <Ctrl+Q+?> | Jump to a marker: Section 4.2.5.
* <Ctrl+Q+A> | Replace <1>: Section 4.2.3.
* <Ctrl+Q+A> | Replace: Section 3.4.2.
* <Ctrl+Q+C> | End of file: Section 4.2.2.
* <Ctrl+Q+D> | End of line: Section 4.2.2.
* <Ctrl+Q+F> | Find <1>: Section 3.4.1.
* <Ctrl+Q+F> | Find: Section 4.2.3.
* <Ctrl+Q+H> | Delete to the beginning of line: Section 4.2.1.
* <Ctrl+Q+R> | Start of file: Section 4.2.2.
* <Ctrl+Q+S> | Start of line: Section 4.2.2.
* <Ctrl+Q+Y> | Delete to the end of line: Section 4.2.1.
* <Ctrl+R> | Page up: Section 4.2.2.
* <Ctrl+S> | Cursor left: Section 4.2.2.
* <Ctrl+T> | Delete to the next word: Section 4.2.1.
* <Ctrl+V> | Overwrite mode: Section 4.2.5.
* <Ctrl+X> | Cursor down: Section 4.2.2.
* <Ctrl+Y> | Erase a line: Section 4.2.1.
* <Del> | Close a window: Section 3.10.8.
* <Del> | Erase a character: Section 4.2.1.
* <Del> | Remove a project item: Section 3.8.4.
* <Del> | Remove from the watches: Section 5.3.3.
* <ENTER> | Activate a button: Section 4.12.
* <ENTER> | Jump to the source line: Section 4.8.
* <ENTER> | Open a project item: Section 4.4.2.
* <ENTER> | Open an include file: Section 4.4.3.
* <ENTER> | Select a item in a Listbox: Section 4.12.
* <ENTER> | Select a menu entry: Section 4.11.
* <ENTER> | Select a message: Section 4.3.
* <ENTER> | Select a window: Section 3.10.8.
* <ENTER> | Select menu item: Chapter 3.
* <ESC> | Leaving a dialog <1>: Section 3.2.1.
* <ESC> | Leaving a dialog <2>: Section 3.9.2.8.
* <ESC> | Leaving a dialog: Section 4.12.
* <F10> | Activate menu bar: Section 4.11.
* <F10> | Menu <1>: Chapter 3.
* <F10> | Menu: Section 1.5.
* <F1> | Help: Section 3.11.1.
* <F1> | Help about the INFO viewer: Section 3.11.1.
* <F1> | Help about the INFO Viewer: Section 4.14.
* <F2> | saving a file: Section 3.2.3.
* <F3> | open a file: Section 3.2.1.
* <F4> | Go to cursor: Section 3.5.4.
* <F5> | Zoom a window: Section 3.10.2.
* <F6> | Next window: Section 3.10.5.
* <F7> | Trace into: Section 3.5.3.
* <F8> | Step over: Section 3.5.2.
* <F9> | Make: Section 3.6.2.
* <Ins> | Add a project item: Section 3.8.3.
* <Shift+> | Resizing a window: Section 3.10.1.
* <Shift+Del> | Cut <1>: Section 4.2.3.
* <Shift+Del> | Cut: Section 3.3.3.
* <Shift+F10> | Macro start: Section 3.3.12.1.
* <Shift+F4> | Go to cursor (No display swap): Section 3.5.4.
* <Shift+F6> | Previous window: Section 3.10.6.
* <Shift+F7> | Trace into (No display swap): Section 3.5.3.
* <Shift+F8> | Step over (No display swap): Section 3.5.2.
* <Shift+Ins> | Paste <1>: Section 4.2.3.
* <Shift+Ins> | Paste: Section 3.3.5.
* <Shift+Space> | Execute a macro: Section 4.2.5.
* <Shift+Tab> | Previous input line: Section 3.9.3.
* <Shift> | Select text: Section 4.2.3.
* <SPACE> | Activate a flag: Section 3.9.2.8.
* <SPACE> | Toggle an option: Section 4.12.
* <Tab> | Next input line: Section 3.9.3.
* Activate a button | <ENTER> |: Section 4.12.
* Activate a flag | <SPACE> |: Section 3.9.2.8.
* Activate menu bar | <F10> |: Section 4.11.
* Add a project item | <Ins> |: Section 3.8.3.
* Again find/replace | <Ctrl+L> |: Section 4.2.3.
* Auto indent | <Ctrl+O> |: Section 4.2.5.
* Begin of file | <Ctrl+PgUp> |: Section 4.2.2.
* Block indenting | <Ctrl+K+Tab> |: Section 4.2.4.
* Block unindenting | <Ctrl+K+Shift+Tab> |: Section 4.2.4.
* Bottom of file | <Ctrl+PgDown> |: Section 4.2.2.
* Call stack | <Ctrl+F3> |: Section 3.7.6.
* Close a window | <Alt+F3> |: Section 3.10.7.
* Close a window | <Del> |: Section 3.10.8.
* Compile | <Alt+F9> |: Section 3.6.1.
* Context help | <Ctrl+F1> |: Section 4.14.
* Copy | <Ctrl+Ins> | <1>: Section 3.3.4.
* Copy | <Ctrl+Ins> |: Section 4.2.3.
* Copy | <Ctrl+K+K> |: Section 4.2.3.
* Cursor down | <Ctrl+X> |: Section 4.2.2.
* Cursor left | <Ctrl+S> |: Section 4.2.2.
* Cursor right | <Ctrl+D> |: Section 4.2.2.
* Cursor up | <Ctrl+E> |: Section 4.2.2.
* Cut | <Ctrl+K+Y> |: Section 4.2.3.
* Cut | <Shift+Del> | <1>: Section 4.2.3.
* Cut | <Shift+Del> |: Section 3.3.3.
* Delete a character | <Ctrl+G> |: Section 4.2.1.
* Delete a character | <Ctrl+H> |: Section 4.2.1.
* Delete selected text | <Ctrl+Del> |: Section 4.2.3.
* Delete to the beginning of line | <Ctrl+Q+H> |: Section 4.2.1.
* Delete to the end of line | <Ctrl+Q+Y> |: Section 4.2.1.
* Delete to the next word | <Ctrl+T> |: Section 4.2.1.
* Delete to the previous word | <Ctrl+Backspace> |: Section 4.2.1.
* End of block | <Ctrl+K+K> |: Section 4.2.4.
* End of file | <Ctrl+Q+C> |: Section 4.2.2.
* End of line | <Ctrl+Q+D> |: Section 4.2.2.
* Erase a character | <Backspace> |: Section 4.2.1.
* Erase a character | <Del> |: Section 4.2.1.
* Erase a line | <Ctrl+Y> |: Section 4.2.1.
* Evaluate/Modify | <Ctrl+F4> |: Section 3.7.2.
* Execute a macro | <Shift+Space> |: Section 4.2.5.
* Find | <Ctrl+Q+F> | <1>: Section 4.2.3.
* Find | <Ctrl+Q+F> |: Section 3.4.1.
* Go to cursor (No display swap) | <Shift+F4> |: Section 3.5.4.
* Go to cursor | <F4> |: Section 3.5.4.
* Goto line | <Ctrl+J> |: Section 3.4.4.
* Help about the INFO Viewer | <F1> |: Section 4.14.
* Help about the INFO viewer | <F1> |: Section 3.11.1.
* Help | <F1> |: Section 3.11.1.
* Ignoring | <Ctrl+C> |: Section 1.3.
* Indent block | <Ctrl+K+I> |: Section 4.2.4.
* Interrupting the compilers | <Ctrl+Break> |: Section 1.3.
* Jump to a line | <Ctrl+J> |: Section 4.2.5.
* Jump to a marker | <Ctrl+Q+?> |: Section 4.2.5.
* Jump to function | <Alt+F2> |: Section 3.4.5.
* Jump to the source line | <ENTER> |: Section 4.8.
* Leaving a dialog | <ESC> | <1>: Section 4.12.
* Leaving a dialog | <ESC> | <2>: Section 3.2.1.
* Leaving a dialog | <ESC> |: Section 3.9.2.8.
* Leaving RHIDE | <Alt+X> |: Section 3.2.7.
* List of all windows | <Alt+0> |: Section 3.10.8.
* List of functions | <Ctrl+F1> |: Section 5.5.2.
* Local options | <Ctrl+O> | <1>: Section 3.8.5.
* Local options | <Ctrl+O> |: Section 4.4.4.
* Macro play | <Ctrl+F10> |: Section 3.3.12.3.
* Macro start | <Shift+F10> |: Section 3.3.12.1.
* Macro stop | <Alt+F10> |: Section 3.3.12.2.
* Make | <F9> |: Section 3.6.2.
* Menu | <F10> | <1>: Chapter 3.
* Menu | <F10> |: Section 1.5.
* Move block | <Ctrl+K+V> |: Section 4.2.4.
* Next input line | <Tab> |: Section 3.9.3.
* Next message | <Alt+F8> |: Section 3.4.6.
* Next window | <F6> |: Section 3.10.5.
* open a file | <F3> |: Section 3.2.1.
* Open a project item | <ENTER> |: Section 4.4.2.
* Open an include file | <ENTER> |: Section 4.4.3.
* Overwrite mode | <Ctrl+V> |: Section 4.2.5.
* Page down | <Ctrl+C> |: Section 4.2.2.
* Page up | <Ctrl+R> |: Section 4.2.2.
* Paste | <Ctrl+K+C> |: Section 4.2.3.
* Paste | <Shift+Ins> | <1>: Section 3.3.5.
* Paste | <Shift+Ins> |: Section 4.2.3.
* Previous input line | <Shift+Tab> |: Section 3.9.3.
* Previous message | <Alt+F7> |: Section 3.4.7.
* Previous window | <Shift+F6> |: Section 3.10.6.
* Program reset | <Ctrl+F2> |: Section 3.5.5.
* Read block from file | <Ctrl+K+R> |: Section 4.2.4.
* Remove a project item | <Del> |: Section 3.8.4.
* Remove from the watches | <Del> |: Section 5.3.3.
* Replace | <Ctrl+Q+A> | <1>: Section 3.4.2.
* Replace | <Ctrl+Q+A> |: Section 4.2.3.
* Resize/move a window | <Ctrl+F5> |: Section 3.10.1.
* Resizing a window | <Shift+> |: Section 3.10.1.
* Run | <Ctrl+F9> |: Section 3.5.1.
* saving a file | <F2> |: Section 3.2.3.
* Search again | <Ctrl+L> |: Section 3.4.3.
* Select a item in a Listbox | <ENTER> |: Section 4.12.
* Select a menu entry | <ENTER> |: Section 4.11.
* Select a message | <ENTER> |: Section 4.3.
* Select a window | <ENTER> |: Section 3.10.8.
* Select menu item | <ENTER> |: Chapter 3.
* Select text | <Shift> |: Section 4.2.3.
* Selecting a window | <Alt> |: Section 4.1.
* Set a marker | <Ctrl+K+?> |: Section 4.2.5.
* Show includes | <Ctrl+I> |: Section 3.8.6.
* Start of block | <Ctrl+K+B> |: Section 4.2.4.
* Start of file | <Ctrl+Q+R> |: Section 4.2.2.
* Start of line | <Ctrl+Q+S> |: Section 4.2.2.
* Step over (No display swap) | <Shift+F8> |: Section 3.5.2.
* Step over | <F8> |: Section 3.5.2.
* Syntax help | <Ctrl+F1> |: Section 3.11.3.1.
* System Menu | <Alt+SPACE> |: Section 3.1.
* To lower | <Ctrl+K+O> |: Section 4.2.4.
* To upper | <Ctrl+K+M> |: Section 4.2.4.
* Toggle a breakpoint | <Ctrl+F8> |: Section 3.7.1.
* Toggle an option | <SPACE> |: Section 4.12.
* Trace into (No display swap) | <Shift+F7> |: Section 3.5.3.
* Trace into | <F7> |: Section 3.5.3.
* Undo | <Alt+Backspace> |: Section 3.3.1.
* Unindent block | <Ctrl+K+U> |: Section 4.2.4.
* Unselect | <Ctrl+K+H> |: Section 4.2.3.
* User screen | <Alt+F5> |: Section 3.10.10.
* Watch an expression | <Ctrl+F7> |: Section 3.7.3.
* Word left | <Ctrl+A> |: Section 4.2.2.
* Word right | <Ctrl+F> |: Section 4.2.2.
* Write block to file | <Ctrl+K+W> |: Section 4.2.4.
* Zoom a window | <F5> |: Section 3.10.2.

